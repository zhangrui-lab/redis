* 压缩列表(Ziplist)是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。
* 另外，当一个哈希键只包含少量键值对，比且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。

#### 压缩列表的构成
* 压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型(sequential)数据结构。一个压缩列表可以包含任意多个节点(entry),每个节点可以保存一个字节数组或者一个整数值。
* 压缩列表各个组成部分的详细说明

  | 属性    | 类型     | 长   度 | 用 途                                                        |
  | ------- | -------- | ------- | ------------------------------------------------------------ |
  | zlbytes | uint32_t | 4字节   | 记录整个压缩列表占用的内存字节数:在对压缩列表进行内存重分配， 或者计算zlend的位置时使用 |
  | zltail  | uint32_t | 4字节   | 记录压缩列表表尾节点距离压缩列表的起始地址有多少字节:通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址 |
  | zllen   | uint16_t | 2字节   | 记录了压缩列表包含的节点数量:当这个属性的值小于UINT16_MAX(65535)时，这个属性的值就是压缩列表包含节点的数量；当这个宿等于UINT16_MAX时，节点的真实数量需要遍历整个压缩列表才能计算得出 |
  | entry   | 列表节点   | 不定    | 压缩列表包含的各个节点，节点的长度由节点保存的内容决定       |
  | zlend   | uint8t   | 1字节   | 特殊值OxFF(十进制255), 用于标记压缩列表的末端             |

#### 压缩列表节点的构成
* 每个压缩列表节点可以保存一个字节数组或者一个整数值，其中，字节数组可以是以下三种长度的其中一种:
  * 长度小于等于63(2^6-1)字节的字节数组；
  * 长度小于等于16383(2^14-1)字节的字节数组
  * 长度小于等于4294967295(2^32-1)字节的字节数组;
* 而整数值则可以是以下六种长度的其中一种:
  * 4位长，介于0至12之间的无符号整数；
  * 1字节长的有符号整数；
  * 3字节长的有符号整数；
  * int16_t类型整数；
  * int32_t类型整数；
  * int64_t类型整数
* 每个压缩列表节点都由previous_entry_length、encoding, content三个部分组成

##### previous_entry_length
* 节点的previous_entry_length属性以字节为单位，记录了压缩列表中前一个节点的长度previous_entry_length属性的长度可以是1字节或者5字节:
* 如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节:前一节点的长度就保存在这一个字节里面。
* 如果前一节点的长度大于等于254字节，那么previous_entry_length属性的长度为5字节:其中属性的第一字节会被设置为OxFE(十进制值254), 而之后的四个字节则用于保存前一节点的长度。
* 因为节点的previous_entry_length属性记录了前一个节点的长度，所以程序可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址。
* 如果我们有一个指向当前节点起始地址的指针c,那么我们只要用指针c减去当前节点previous_entry_length属性的值，就可以得出一个指向前一个节点起始地址的指针P。
* 压缩列表的从表尾向表头遍历操作就是使用这一原理实现的，只要我们拥有了一个指向某个节点起始地址的指针，那么通过这个指针以及这个节点的previous_entry_length属性，程序就可以一直向前一个节点回溯，最终到达压缩列表的表头节点。

##### encoding
* 节点的encoding属性记录了节点的content属性所保存数据的类型以及长度:
  * 一字节、两字节或者五字节长，值的最高位为00、01或者10的是字节数组编码: 这种编码表示节点的content属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录；
  * 一字节长，值的最高位以11开头的是整数编码: 这种编码表示节点的content属 性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录；
* 字节数组编码

  | 编 码                                  | 编码长度 | content属性保存的值               |
  | -------------------------------------- | -------- | --------------------------------- |
  | 00 bbbbbb                              | 1字节    | 长度小于等于63字节的字节数组      |
  | 01 bbbbbb xxxxxxxx                     | 2字节    | 长度小于等于16383字节的字节数组   |
  | 10 aaaaaaaa bbbbbbbb cccccccc dddddddd | 5字节    | 长度小于等于4294 967295的字节数组 |

* 整数编码

  | 编码     | 编码长度 | content属性保存的值                                          |
  | -------- | -------- | ------------------------------------------------------------ |
  | 11000000 | 1字节    | intl6 t类型的整数                                            |
  | 11010000 | 1字节    | int32 t类型的整数                                            |
  | 11100000 | 1字节    | int64 t类型的整数                                            |
  | 11110000 | 1字节    | 24位有符号整数                                               |
  | 11111110 | 1字节    | 8位有符号整数                                                |
  | 1111xxxx | 1字节    | 使用这一编码的节点没有相应的content属性，因为编码本身的xxxx四个位已经保存了一个介于0和12之间的值，所以它无须content属性 |

#####  content
* 节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。

#### 连锁更新
* 前面说过，每个节点的previous_entry_length属性都记录了前一个节点的长度: 
  * 如果前一节点的长度小于254字节，那么previous_entry_length属性需要用1字节长的空间来保存这个长度值。
  * 如果前一节点的长度大于等于254字节，那么previous_entry_length属性需要用5字节长的空间来保存这个长度值。
* Redis将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”(cascade update )
* 除了添加新节点可能会引发连锁更新之外，删除节点也可能会引发连锁更新。
* 因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(N), 所以连锁更新的最坏复杂度为O(N^2)。
* 要注意的是，尽管连锁更新的复杂度较高，但它真正造成性能问题的几率是很低的.
* 首先，压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点， 连锁更新才有可能被引发，在实际中，这种情况并不多见；
* 其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响:
  * 比如说，对三五个节点进行连锁更新是绝对不会影响性能的；
  * 因为以上原因，ziplistPush等命令的平均复杂度仅为O(N)，在实际中，我们可以放心地使用这些函数，而不必担心连锁更新会影响压缩列表的性能。

#### 压缩列表API
* 所有用于操作压缩列表的API

  | 函数               | 作用                                                         | 算法复杂度                                                   |
  | ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | ziplistNew         | 创建一个新的压缩列表                                         | O(1)                                                           |
  | ziplistPush        | 创建一个包含给定值的新节点，并将这个新节点添加到压缩列表的表头或者表尾 | 平均O(N),最坏O(N^2)                                          |
  | ziplistinsert      | 将包含给定值的新节点插入到给定节点之后                       | 平均O(N),最坏O(N^2)                                          |
  | ziplistindex       | 返回压缩列表给定索引上的节点                                 | O(N)                                                         |
  | ziplistFind        | 在压缩列表中査找并返回包含了给定值 的节点                    | 因为节点的值可能是一个字节数组， 所以检查节点值和给定值是否相同的复杂度为O(N)，而査找整个列表的复杂度 则为O(N^2) |
  | ziplistNext        | 返回给定节点的下一个节点                                     | O(1)                                                             |
  | ziplistPrev        | 返回给定节点的前一个节点                                     | O(1)                                                              |
  | ziplistGet         | 获取给定节点所保存的值                                       | O(1)                                                             |
  | ziplistDelete      | 从压缩列表中删除给定的节点                                   | 平均O(N), 最坏O(N^2)                                         |
  | ziplistDeleteRange | 删除压缩列表在给定索引上的连续多个 节点                      | 平均O(N), 最坏O(N^2)                                         |
  | ziplistBlobLen     | 返回压缩列表目前占用的内存字节数                             | O(1)                                                            |
  | ziplistLen         | 返回压缩列表目前包含的节点数量                               | 节点数量小于65535时为0(1),大于65535 时为 O(N)                |
