* Redis没有直接使用C语言传统的字符串表示(以空字符结尾的字符数组)，而是自己构建了一种名为简单动态字符串(simple dynamic string, SDS )的抽象类型，并将SDS用作Redis的默认字符串表示。
* 在Redis里面，C字符串只会作为字符串字面量用在一些无须对字符串值进行修改的地方，比如打印日志
* 当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，Redis 就会使用SDS来表示字符串值，比如在Redis的数据库里面，包含字符串值的键值对在底层都是由SDS实现的。
* SDS还被用作缓冲区(buffer): AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区，都是由SDS实现的。

#### SDS的定义

```c
struct sdshdr {
	int len;
    int free;
    char buf[];
}
```

* SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由SDS函数自动完成的，所以这个空字符对于SDS的使用者来说是完全透明的。 遵循空字符结尾这一惯例的好处是，SDS可以直接重用一部分C字符串函数库里面的函数。 

##### 杜绝缓冲区溢出

* 除了获取字符串长度的复杂度高之外，C字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出。
* 与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢岀的可能性:当SDS API需要对SDS进行修改时，API会先检査SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出问题。

##### 减少修改字符串时带来的内存重分配次数

* 正如前两个小节所说，因为C字符串并不记录自身的长度，所以对于一个包含了N个字符的C字符串来说，这个C字符串的底层实现总是一个N + 1个字符长的数组(额外的一个字符空间用于保存空字符)。因为C字符串的长度和底层数组的长度之间存在着这种关联性，所以每次增长或者缩短一个C字符串，程序都总要对保存这个C字符串的数组进行一次内存重分配操作:
  * 如果程序执行的是增长字符串的操作，比如拼接操作(append),那么在执行这个操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小。如果忘了这一步就会产生缓冲区溢出。
  * 如果程序执行的是缩短字符串的操作，比如截断操作(trim), 那么在执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间。如果忘了这一步就会产生内存泄漏。
* 因为内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以它通常是一个比较耗时的操作:
  * 在一般程序中，如果修改字符串长度的情况不太常出现，那么每次修改都执行一次内存重分配是可以接受的。
  * 但是Redis作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，如果每次修改字符串的长度都需要执行一次内存重分配的话，那么光是执行内存重分配的时间就会占去修改字符串所用时间的一大部分，如果这种修改频繁地发生的话，可能还会对性能造成影响。
* 为了避免C字符串的这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联:在SDS中，buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。

###### 空间预分配

* 空间预分配用于优化SDS的字符串增长操作:当SDS的API对一个SDS进行修改， 并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间。其中，额外分配的未使用空间数量由以下公式决定:
  * 如果对SDS进行修改之后，SDS的长度(也即是len属性的值)将小于1MB, 那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。举个例子，如果进行修改之后，SDS的len将变成13字节，那么程序也会分配13字节的未使用空间，SDS的buf数组的实际长度将变成 13 + 13 + 1=27字节(额外的一字节用于保存空字符)。
  * 如果对SDS进行修改之后，SDS的长度将大于等于1MB,那么程序会分配1MB的未使用空间。举个例子，如果进行修改之后，SDS的len将变成30MB,那么程序会分配1MB的未使用空间，SDS的buf数组的实 际长度将为30 MB + 1MB + lbyte
  * 通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数。
* 在扩展SDS空间之前，SDS API会先检査未使用空间是否足够，如果足够的话，API 就会直接使用未使用空间，而无须执行内存重分配。
* 通过这种预分配策略，SDS将连续增长N次字符串所需的内存重分配次数从必定N次降低为最多N次。

###### 惰性空间释放

* 惰性空间释放用于优化SDS的字符串缩短操作:当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。
  * 注意执行sdstrim之后的SDS并没有释放多出来的8字节空间，而是将这8字节空间作为未使用空间保留在了 SDS里面，如果将来要对SDS进行增长操作的话，这些未使用空间就可能会派上用场。
* 通过惰性空间释放策略，SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化。
* 与此同时，SDS也提供了相应的API,让我们可以在有需要时，真正地释放SDS的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。

##### 二进制安全

* c字符串中的字符必须符合某种编码(比如ASCII ),并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。
  * 举个例子，如果有一种使用空字符来分割多个单词的特殊数据格式， 那么这种格式就不能使用C字符串来保存
* 虽然数据库一般用于保存文本数据，但使用数据库来保存二进制数据的场景也不少见， 因此，为了确保Redis可以适用于各种不同的使用场景，SDS的API都是二进制安全的 (binary-safe ),所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据， 
  程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，它被读取时就是什么样。这也是我们将SDS的buf属性称为字节数组的原因——Redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据。
  * 例如.使用SDS来保存之前提到的特殊数据格式就没有任何问题，因为SDS使用len属性的值而不是空字符来判断字符串是否结束
* 通过使用二进制安全的SDS,而不是C字符串，使得Redis不仅可以保存文本数据，还可以保存任意格式的二进制数据。

##### 兼容部分C字符串函数

* 虽然SDS的API都是二进制安全的，但它们一样遵循C字符串以空字符结尾的惯例: 这些API总会将SDS保存的数据的末尾设置为空字符，并且总会在为buf数组分配空间时多分配一个字节来容纳这个空字符，这是为了让那些保存文本数据的SDS可以重用一部分 <string.h>库定义的函数。

##### 总结

* C字符串和SDS之间的区别

  | C字符串                                    | SDS                                        |
  | ------------------------------------------ | ------------------------------------------ |
  | 获取字符串长度的复杂度为O(N)               | 获取字符串长度的复杂度为0(1)               |
  | API是不安全的，可能会造成缓冲区溢出        | API是安全的，不会造成缓冲区溢出            |
  | 修改字符串长度N次必然需要执行N次内存重分配 | 修改字符串长度N次最多需要执行N次内存重分配 |
  | 只能保存文本数据                           | 可以保存文本或者二进制数据                 |
  | 可以使用所有＜string.h＞库中的函数         | 可以使用一部分＜string.h＞库中的函数       |

#### SDS API

* SDS的主要操作API

  | 函数        | 作 用                                                        | 时间复杂度                                                |
  | ----------- | ------------------------------------------------------------ | --------------------------------------------------------- |
  | sdsnew      | 创建一个包含给定C字符串的SDS                                 | O(N), N为给定C字符串的长度                                |
  | sdsempty    | 创建一个不包含任何内容的空SDS                                | O⑴                                                        |
  | sdsfree     | 释放给定的SDS                                                | O(N), N为被释放SDS的长度                                  |
  | sdslen      | 返回SDS的已使用空间字节数                                    | 这个值可以通过读取SDS的len属性来 直接获得，复杂度为0(1)   |
  | sdsavail    | 返回SDS的未使用空间字节数                                    | 这个值可以通过读取SDS的free属性 来直接获得，复杂度为。(1) |
  | sdsdup      | 创建一个给定SDS的副本(copy )                                 | O(N)，N为给定SDS的长度                                    |
  | sdsclear    | 清空SDS保存的字符串内容                                      | 因为惰性空间释放策略，复杂度为0(1)                        |
  | sdscat      | 将给定C字符串拼接到SDS字符串的末尾                           | O(N), N为被拼接C字符串的长度                              |
  | sdscatsds   | 将给定SDS字符串拼接到另一个SDS字符串 的末尾                  | O(N), N为被拼接SDS字符串的长度                            |
  | sdscpy      | 将给定的C字符串复制到SDS里面，覆盖SDS原有的字符串            | 0(N), N为被复制C字符串的长度                            |
  | sdsgrowzero | 用空字符将SDS扩展至给定长度                                  | 0(N),N为扩展新增的字节数                                |
  | sdsrange    | 保留SDS给定区间内的数据，不在区间内的 数据会被覆盖或清除     | 0(N),N为被保留数据的字节数                              |
  | sdstrim     | 接受一个SDS和一个C字符串作为参数，从SDS中移除所有在C字符串中出现过的字符 | O(N^2), N为给定C字符串的长度                              |
  | sdscmp      | 对比两个SDS字符串是否相同                                    | O(N)，N为两个SDS中较短的那个SDS 的长度                  |
