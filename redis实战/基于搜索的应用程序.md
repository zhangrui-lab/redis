* Redis特别适用于解决基于搜索的问题(search-based problem ),这类问题通常需要使用集合以及有序集合的交集、并集和差集操作查找符合指定要求的元素。

#### 使用Redis进行搜索

* 当用户在文本编辑器或者文字处理软件中搜索一个单词或者句子的时候，软件就会对文件进 行扫描并寻找那个单词或者句子。如果读者曾经使用过Linux、Unix或者OS X的grep程序， 或者曾经使用过Windows内置的文件搜索功能来査找包含特定单词或者句子的文件，那么应该 就会注意到，被搜索文件的数量越多、体积越大，搜索花费的时间也会越长。
* 与在本地电脑上面进行的搜索不同，在Web上面搜索Web页面或者其他内容的速度总是非 常快的，即使在文档的体积和数量都非常巨大的情况下，也是如此。在这一节中，我们将学习如 何改变程序搜索数据的方式，并使用Redis来减少绝大部分基于单词或者关键字进行的内容搜索 操作的执行时间。
* 我们首先要做的就是思考这样一个问题:比起一个单词接一个单词地扫描文档，如何才能以 更快的速度对文档进行搜索？

##### 基本搜索原理

* 为了获得比扫描文档更快的搜索速度，我们需要对文档进行预处理，这个预处理步骤通 常被称为建索引(indexing),而我们要创建的结构则被称为反向索引(inverted indexes )o反 向索引是互联网上绝大部分搜索引擎所使用的底层结构，它在搜索领域里面几乎无人不知。 从很多方面来看，创建反向索引就像是在生成一些类似于书本末尾的索引那样的东西。我们 选择使用Redis来创建反向索引的原因在于，Redis自带的集合和有序集合①都非常适合于处 理反向索引。
* 具体来说，反向索引会从每个被索引的文档里面提取出一些单词，并创建表格来记录每篇文章者K包含了哪些单词。
* 索引操作的最终执行结果就是产生一些 Redis集合

###### 基本索引操作

* 为了给文档构建索引集合，程序首先需要对文档包 含的单词进行处理。从文档里面提取单词的过程通常被称为语法分析(parsing )和标记化(tokenization ),这个过程可以产生出一系列用于标识文档的标记(token), 标记有时候又被称为单词(word)。
* 生成标记的方法有很多种。用于处理Web页面的 方法，与处理关系数据库的行或者处理文档数据库的 文档所使用的方法，可能会有所不同。为了让标记化 过程保持简单，我们认定单词只能由英文字母和单引号组成，并且每个单词至少要有两个字符长。这一 规则可以覆盖大部分英文单词，并忽略诸如I和a这 样的单词。
* 标记化的一个常见的附加步骤，就是移除内容中的非用词(stop word )。非用词就是那些在文档中频繁岀现 但是却没有提供相应信息量的单词，对这些单词进行搜 索将返回大量无用的结果。移除非用词不仅可以提高搜 索性能，还可以减少索引的体积。
* 从索引里面移除文档如果被索引文档的内容可能会随着时间而出现变化，那么就需要有一个功能 来自动删除文档已有的索引并重新建立索引，或者智能地为文档删除无效的索引并添加新索引。实 现这个功能的一个比较简单的方法，就是使用JSON编码的列表把文档已经建立了索引的单词记录 起来，并通过SET命令将这个列表存储到一个键里面，最后再在index_document ()函数的开 头添加一些删除不必要索引的代码.

###### 基本搜索操作

* 在索引里面查找一个单词是非常容易的，程序只需要获取单词集合里面的所有文档就 可以了。但是要根据两个或多个单词查找文档的话，程序就需要把给定单词集合里面的所 有文档都找出来，然后再从中找到那些在所有单词集合里面都出现了的文档。第3章中曾 经介绍过如何使用Redis的SINTER命令和SINTERSTORE命令来找出那些同时存在于所 有给定集合的元素，而这一次，我们同样可以使用这两个命令来找出那些包含了所有给定单词的文档。
* 使用交集操作处理反向索引的好处不在于能够找到多少文档，甚至不在于能够多快地找出结 果，而在于能够彻底地忽略无关的信息。在以文本编辑器的方式对文本进行搜索的时候，很多无用的数据都会被仔细检查，但是因为反向索引已经知道了每篇文档包含的单词，所以程序只需要 对文档进行过滤，找出那些包含了所有给定单词的文档就可以了。
* 用户有些时候可能会想要使用多个具有相同意思的单词进行搜索，并把它们看作是同一个单 词，我们把这样的单词称为同义词。为了处理这种情况，程序可以取出同义词对应的全部文档集合, 并从中找出所有独一无二的文档，或者直接使用Redis内置的SUNION命令或者SUNIONSTORE 命令。
* 除此之外，用户可能偶尔也想要搜索那些包含了某些特定单词或者句子，但是并不包含另 外一些单词或句子的文档，使用Redis的SDIFF和SDIFFSTORE这两个集合命令可以做到这 一点。
* 通过使用Redis的集合操作以及一些辅助代码，程序可以对文档执行各种复杂的单词查询操 作。代码清单7-2展示了一组辅助函数，它们可以对给定单词对应的集合执行交集计算、并集计 算和差集计算，并将计算结果存储到一个默认过期时间为30秒的临时集合里面。

###### 分析并执行搜索

* 到目前为止，我们已经具备了建立索引和进行捜索所需的绝大部分工具，包括标记化函数、 索引函数以及基本的交集计算函数、并集计算函数和差集计算函数，唯一缺少的就是一个将文本 查询语句转换成搜索操作的函数。为此，我们将实现一个搜索函数，它可以查找那些包含了所有 给定单词的文档，并允许我们指定同义词以及不需要的单词。
* 最基本的搜索旨在找出那些包含了所有给定单词的文档。如果用户只是单纯地给出了一些单 词，那么搜索程序只需要直接执行一个intersect ()调用就可以了。如果用户在某个单词的前 面加上了一个减号(-)，那么就表示用户不希望包含这个单词的文档出现在搜索结果里面，搜 索程序就需要使用difference ()移除相应的文档。如果用户在某个单词的前面加上了一个 加号( + ),那么就表示这个单词是前一个单词的同义词，搜索程序首先会收集各个同义词组并 对它们执行union ()操作，然后再执行高层次的intersect ()调用(如果带+号的单词前面 有带-号的单词，那么程序会略过那些带-号的单词，并把最先遇到的不带-号的单词看作是同 义词)。

##### 对搜索结果进行排序

* 虽然我们已经可以根据给定的单词对索引内的文档进行搜索，但这只是我们检索所需信息的 第一步。搜索程序在取得多个文档之后，通常还需要根据每个文档的重要性对它们进行排序一一 搜索领域把这一问题称为关联度计算问题，而判断一个文档是否比另一个文档具有更高关联度的 其中一种方法，就是看哪个文档的更新时间最接近当前时间。接下来我们将学习如何在搜索结果 中引入对关联度的支持。

#### 有序索引

* 上一节主要讨论了如何使用Redis实现搜索功能，并通过引用存储在散列里面的数据对搜索 结果进行排序。这种排序方法非常适合在元素的排列顺序(sort order)可以用字符串或者数字表示的情况下使用，但它并不能处理元素的排列顺序由几个不同分值组合而成的情况。本节将展示 如何使用集合以及有序集合实现基于多个分值的复合排序操作，它能够提供比SORT命令更高的 灵活性。
* 稍早之前，在使用SORT命令从散列里面获取排序所需数据的时候，散列的作用与关系数据库 里面的行非常相似。如果我们把文章的更新时间存储到有序集合里面，然后通过ZINTERSTORE命 令以及它的MAX聚合函数，对存储了文章搜索结果的集合以及存储了文章更新时间的有序集合执 行交集计算，那么就可以根据文章的更新时间对搜索结果内的所有文章进行排序。

##### 使用有序集合对搜索结果进行排序

* Redis允许用户将集合作为参数传入ZINTERSTORE和ZUNIONSTORE 等有序集合命令里面，并把集合成员的分值看作是1来进行计算。
* 在对文档进行搜索并得出结果集合之后，程序可以使用SORT命令对结果集合进行排序，但 这也意味着程序每次只能基于单一的标准对结果进行排序，尽管能够方便地基于单一的标准进行 排序正是我们当初使用索引进行排序的原因之一。

##### 使用有序集合实现非数值排序

* 常见的字符串比较操作都会一个字符接一个字符地对两个字符串进行检查，直到发现一个不 相等的字符，或者发现其中一个字符串比另一个字符串更短，又或者确认两个字符串相等为止。 为了给存储在Redis里面的字符串数据提供类似的功能，我们需要把字符串转换为数字。本节将 介绍把字符串转换为数字的方法，并将这些数字存储到Redis的有序集合里面，从而实现基于字符串前缀的排序功能。
* 将字符串转换为数字首先要做的就是了解这种转换的局限性。因为在Redis里面，有序集合的分值是以IEEE 754双精度浮点数格式存储的，所以转换操作最大只能使用64个二进制位，并 且由于浮点数格式的某些细节，转换操作并不能使用全部64个二进制位。使用63个以上的二进 制位从技术上来说是可行的，但带来的效果并不比只使用63个二进制位要好多少，为了简单起 见，本节展示的例子只使用了 48个二进制位，这使得我们的程序只能基于数据的前6个字节进 行前缀排序，但是一般来说这种程度的前缀排序已经足够了。
* 为了将字符串转换为整数，程序首先 需要把长度超过6个字符的字符串截断为6个字符长，或者把长度不足6个字符的字符串扩展至 6个字符长，接着把字符串的每个字符都转换成ASCII值，最后将这些ASCII值合并为一个整数。
* 因为基于字符串生成的分值除了定义排列顺序之外并不具有实际的意义，所以它们通常只会 用于单独进行排序，而不会与其他分值一起进行组合排序。
* 既然我们已经知道了如何基于数值或者字符串进行排序，也知道了如何通过权重来调整和组合数值数据，那么接下来是时候了解一下如何使用Redis的集合和有序集合来实现广告定向操作了。

#### 广告定向

* 互联网的无数网站上，都充斥着各种文字、短语、图像或者视频形式的广告，这些广告是搜 索网站、景点信息网站、甚至词典网站的拥有者创造收入的一种方式。

##### 什么是广告服务器

* 本书所说的广告服务器，是指一种小而复杂的技术。每当用户访问一个带有广告的Web页面时， Web服务器和用户的Web浏览器都会向远程服务器发送请求以获取广告，广告服务器会接收各种各样的信息，并根据这些信息找出能够通过点击、浏览或动作(具体的信息稍后就会介绍)获得最大经济收益的广告。
* 广告服务器需要接受一系列定向参数以便挑选出具体的广告，这些参数至少需要包含浏览者 的基本位置信息(这些信息通常来源于IP地址，偶尔也会来源于浏览者手机或电脑上的GPS信息)、浏览者使用的操作系统以及Web浏览器、可能还有浏览者正在浏览的页面的内容，甚至浏 览者在当前网站上最近浏览过的一些页面。
* 广告预算 
  * 在典型的定向广告平台上面，每个广告通常都会带有一个随着时间减少的预算。本节不会介绍计算广告预算或者进行广告记账的方法，对这方面有兴趣的读者可以自己想办法实现这 两个功能。一般来说，广告预算应该被分配到不同的时间上面，笔者发现的一种实用且有效的方 法，就是基于小时数对广告的总预算进行划分，并在同一个小时的不同时间段把预算分配给不同 的广告。
* 要向用户展示广告，首先要做的就是把广告放到广告平台里面

##### 对广告进行索引

* 针对广告的索引操作和针对其他内容的索引操作并没有太大的不同。广告索引操作的特别之 处在于它返回的不是一组广告或者一组搜索结果，而是单个广告；并且被索引的广告通常都拥有像位置、年龄或性别这类必须的定向参数。
* 在讨论如何对广告进行索引之前，我们首先需要确定如何以一致的方式评估广告的价格。

###### 计算广告的价格

* Web页面上展示的广告主要有3种类型:按展示次数计费(cost per view )、按点击次数计费 (cost per click )和按动作执行次数计费(cost per action )
* 按动作执行次数计费又称按购买次数计费(cost per acquisition )。按展示次数计费的广告又称CPM广告或按千次计费(cost per mille ) 广告，这种广告每展示1000次就需要收取固定的费用。按点击计费的广告又称CPC广告，这种广告根据被点击的次数收取固定的费用。按动作执行次数计费的广告又称CPA广告，这种广告根 据用户在广告的目的地网站上执行的动作收取不同的费用。

###### 让广告的价格保持一致

* 为了尽可能地简化广告价格的计算方式，程序将对所有类型的广告进行转换，使得它们的价 格可以基于每千次展示进行计算，产生出一个估算CPM ( estimated CPM ),简称eCPM。对于 CPM广告来说，因为这种广告已经给出了 CPM价格,所以程序只要直接把它的CPM用作eCPM 就可以了。至于CPC广告和CPA广告，程序则需要根据相应的规则为它们计算出eCPM。
* 计算CPC广告的eCPM

  * 对于CPC广告，程序只要将广告的每次点击价格乘以广告的点击通过率(click-through rate, CTR), 然后再乘以1000,得出的结果就是广告的eCPM (其中点击通过率可以用广告被点击的次数除以广告展示的次数计算得出)。举个例子，如果广告的每次点击价格为0.25美元，通过率为0.2% (也就是0.002 ),那么广告的eCPM为0.25 x 0.002 x 1000 = 0.5美元。
* 计算CPA广告的eCPM
  * CPA广告计算eCPM的方法和CPC广告计算eCPM的方法在某种程度上是相似的。程序只需要将广告的点击通过率、用户在广告投放者的目标页面上执行动作的概率、被执行动作的价格 这三者相乘起来，然后再乘以1000,得出的结果就是广告的eCPM。举个例子，如果广告的点击通过率为0.2%,用户执行动作的概率为10% (也就是0.1 ),而广告的CPA为3美元，那么广告 的 eCPM 为 0.002 x 0.1 x 3 * 1000 = 0.60 美元。
* 因为点击通过率是由点击次数除以展示 次数计算出来的，而动作的执行概率则 是由动作执行次数除以点击次数计算出来的，所以这两个概率相乘的结果等于 动作执行次数除以展示次数。

###### 将广告插入索引

* 对广告进行定向需要用到一组定向参数，其中既有可选的参数，也有必须的参数。为了正确 地进行广告定向，广告的索引必须考虑定向的需求。本节要实现的定向广告系统接受两个定向选 项:位置和内容。其中位置选项(包括城市、州和国家)是必须的，而广告与页面内容之间的任 何匹配单词则是可选的，并且只作为广告的附加值存在。
* 按需将不同类型的服务划分到了不同的机器或数据库上面，从而确保广告定向索引不会意外地覆盖了其他内容的索引。
* 广告定向系统也会使用由集合和有序集合构成的反向索引来存储广告ID。必 须的位置定向参数会被存储到集合里面，并且这些位置参数不会提供任何附加值。
* 当广告文案与页面内容相匹配的时候，广告就会和页面融为一体，使得广告被点击的机会要高于那些与 页面内容毫无关联的广告。

##### 执行广告定向操作

* 正如之前所说，当系统收到广告定向请求的时候，它要做的就是在匹配用户所在位置的一系列广告里面，找出eCPM最高的那一个广告。除了基于位置对广告进行匹配之外，程序还会记录页面内容与广告内容的匹配程度，以及不同匹配程度对广告点击通过率的影响等统计数据。通过使用这些统计数据，广告中与Web页面相匹配的那些内容就会作为附加值被计入由CPC和CPA 计算岀的eCPM里面，使得那些包含了匹配内容的广告能够更多地被展示出来。
* 在展示广告之前，系统不会为Web页面的任何内容设置附加值。但是当系统开始展示广告 的时候，它就会记录下广告中包含的哪个单词改善或者损害了广告的预期效果，并据此修改各个 可选的定向单词的相对价格。
* 为了执行定向操作，系统将对所有相关的位置集合执行并集计算操作，产生出最初的一组广 告，并向浏览者进行展示。之后系统会分析广告所在的页面，添加相关的附加值，并最终为每个 广告都计算出一个总计(total) eCPM值。在计算出每个广告的eCPM之后，系统会获取eCPM 最高的那个广告的ID,记录一些关于本次定向操作的统计数据，最后返回被获取的广告。

##### 从用户行为中学习

* 当广告被展示给用户观看的时候，我们将有机会了解到用户点击广告的原因。
* 我们之所以需要通过Web内容中的单词来寻找更好的广告，一个简单的原因在于广告投放 的效果归根结底是由上下文决定的:在一个讨论儿童玩具安全性的Web页面上展示跑车广告并 不是什么好主意。通过对广告中的单词和Web页面内容中的单词进行匹配，程序可以简单快速 地完成上下文匹配工作。

###### 浏览记录

* 实现用户行为学习操作的首要步骤，就是调用之前在代码record_targeting_result()函数，把那些与广告定向操作执行结果有关的信息记录下来，并在之后 使用被记录的信息计算点击通过率、动作执行率以及每个单词最终的eCPM附加值。被记录的信 息包括:
  * 被定向至给定广告的单词；
  * 给定广告被定向的总次数；
  * 广告中的某个单词被用于计算附加值的总次数。
* 为了记录这些信息，程序将使用集合存储被定向的单词，并为每个广告创建一个有序集合， 用于存储广告的展示次数以及广告包含的各个单词的展示次数。

###### 记录点击和动作

* 因为我们构建的定向广告平台会对广告的展示次数进行记录，所以计算点击通过率的其中一 半数据已经被记录起来了。而计算点击通过率所需的另一半数据就是点击量(对于按动作计费的 广告来说，则是动作执行次数)。从数字上来看，因为我们的eCPM计算方法是基于公式(每次 点击的价格或每个动作的价格)x (点击量或动作执行次数)/ (广告的展示次数)计算得出的， 所以如果系统不记下点击量或者动作执行次数的话，那么价格计算公式中的分子就会为0,使得 计算没办法得出一个有用的结果。
* 当用户点击某个广告的时候，在将用户引导至广告的目的地之前，系统会根据广告的类型， 将这次点击计入为该类型广告而设置的点击计数器里面，同时被记录下来的还有被点击的广告， 以及与被点击广告相匹配的单词。

###### 更新eCPM

* 前面的两节已经对update_cpms ()函数的用法做了不少介绍，读者对它的作用应该已经有 了大致的了解。接下来的内容将对这个函数的各个部分进行介绍，说明它是如何对广告包含的每 个单词的附加值进行更新的，以及它又是如何对各个广告的eCPM进行更新的。
* 更新eCPM首先要做的就是计算出广告的点击通过率。因为我们的广告平台一直都有记录每 个广告的点击量和展示次数，所以程序只需要从相应的有序集合里面取出广告的点击量和展示次 数，然后就可以计算广告的点击通过率了。接着，程序只要从广告的基本价格有序集合里面取出 广告的实际价格，并将它和点击通过率结合起来，就可以计算出广告的eCPM。
* 更新eCPM的第二个步骤，就是要计算出与广告匹配的那些单词的点击通过率。和之前一 样，因为广告平台记录了每个单词的展示次数和点击量，所以程序同样可以基于这两样信息计 算出单词的点击通过率，接着又可以基于这个点击通过率和广告的基本价格计算出单词的 eCPMo在计算出单词的eCPM之后，程序可以通过使用单词eCPM减去广告eCPM的方法来 得出单词的附加值，并将这个附加值存储到为广告包含的每个单词分别记录附加值的有序集合 里面。
* 除了计算时使用的是动作计数有序集合而不是点击计数有序集合之外，程序在更新eCPM 时对动作和点击执行的计算是相同的。代码清单7-16展示了负责为点击和动作更新eCPM的 函数。

#### 职位捜索

* 大多数人应该都曾经花时间查看过在线的分类求职网站，或者通过招聘机构尝 试找到一份合适的工作。在了解了职位所在的办公地点之后，我们首先要考虑的就是职位的经验 要求以及技能要求。

##### 逐个查找合适的职位

* 初看上去，似乎有一个直截了当的方案可以解决寻找合适职位的问题:如果每个职位都有一 个属于自己的集合，集合里面记录了获取这个职位所需的技能，那么程序只需要将求职者拥有的 所有技能也添加到一个集合里面,然后对职位所需技能集合以及求职者拥有技能集合执行SDIFF操作，就可以知道求职者是否满足职位的技能需求。如果SDIFF的计算结果不包含任何技能， 那么说明求职者具备职位要求的全部技能。
* 通过检查求职者是否具备职位所需的全部技能来判断求职者是否能够胜任该职位。这个解决方案虽然可以正常运行，但它的问题在于，为了找出求职者适合的所有职位，程序必须对每个职位进行单独的检查，而这种做法毫无疑问是无法进行性能扩展的，因此 我们需要使用接下来介绍的另一个方法来为求职者寻找合适的职位。

##### 以搜索方式查找合适的职位

* 与其对职位及其所需的技能进行讨论，不如像本章之前介绍过的其他搜索问题一样，换个角 度来思考这个问题。我们首先要做的，就是把各个职位要求的技能数量都存储到一个记录职位所 需技能数量的有序集合里面。
* 为了找出求职者能够满足全部技能要求的那些职位, 程序会找出求职者拥有的所有技能，并对这些技 能对应的集合执行 ZINTERSTORE 操作，从而计算出求职者对于每个职位的得分，这些得分代表求职者满足了职位所需技能中的多少项技能。
* 在将求职者的得分都存储到有序集合里面之后，程序将对权重为T的求职者得分有序集合以 及权重为1的职位所需技能数量有序集合执行 ZINTERSTORE 操作。在计算得出的结果有序集合 里面，分值为0的职位就是求职者满足了所有技能要求的职位。
* 首先会计算出求职者对于每个职位的得分，然后使用胜 任这些职位所需的总分减去求职者在这些职位上面的得分，在最后得出的结果有序集合里面，分 值为0的职位就是求职者能够胜任的职位。
* 这个职位搜索系统的运行速度取决于被搜索职位的数量以及搜索执行的次数，当职位的数量比较多的时候，更是如此。但是通过使用分片技术，程序可以将大规模的计算分 割为多个小规模的计算，然后逐步计算岀每个小计算的结果。另外一种可选的方法，则是在进行 职位搜索的时候，先从一个地点集合里面取出位于该地点的所有职位，然后使用用于优化广告定向操作的方法来优化职位搜索操作，这将极大地提升职位搜索程序的性能。