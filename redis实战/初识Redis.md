

Redis是一个远程内存数据库，它不仅性能强劲，而且还具有复制特性以及为解决问题而生 的独一无二的数据模型。Redis提供了 5种不同类型的数据结构，各式各样的问题都可以很自然 地映射到这些数据结构上:Redis的数据结构致力于帮助用户解决问题，而不会像其他数据库那 样，要求用户扭曲问题来适应数据库。除此之外，通过复制、持久化(persistence )和客户端分片(client-side sharding )等特性，用户可以很方便地将Redis扩展成一个能够包含数百GB数据、 每秒处理上百万次请求的系统。

* 分片是一种将数据划分为多个部分的方法，对数据的划分可以基于键包含的ID、基于键的散列值，或者基于以上两者的某种组合，通过对数据进行分片，用户可以将数据存储到多台机器里面，也可以从多台机器里面获取数据，这种方法在解决某些问题时可以获得线性级别的性能提升。借助存储，以及如何通过复制、持久化和事务等手段保证数据的完整性。

#### Redis 简介

* Redis是一个速度非常快的非关系数据库(non-relational database),它可以存储键(key)与5种不同类型的值(value )之间的映射(mapping ),可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来扩展读性能，还可以使用客户端分片来扩展写性能。

##### Redis与其他数据库和软件的对比

* 如果你熟悉关系数据库，那么你肯定写过用来关联两个表的数据的SQL查询。而Redis则属 于人们常说的NoSQL数据库或者非关系数据库:Redis不使用表，它的数据库也不会预定义或者强制去要求用户对Redis存储的不同数据进行关联。

* 高性能键值缓存服务器memcached也经常被拿来与Redis进行比较:这两者都可用于存储键值映射，彼此的性能也相差无几，但是Redis能够自动以两种不同的方式将数据写入硬盘，并且Redis除了能存储普通的字符串键之外，还可以存储其他4种数据结构，而memcached 只能存储普通的字符串键。这些不同之处使得Redis可以用于解决更为广泛的问题，并且既可以用作主数据库(primary database )使用，又可以作为其他存储系统的辅助数据库(auxiliary database ) 使用。

* 一般来说，许多用户只会在Redis的性能或者功能是必要的情况 下，才会将数据存储到Redis里面:如果程序对性能的要求不高，又或者因为费用原因而没办法将大量数据存储到内存里面，那么用户可能会选择使用关系数据库，或者其他非关系数据库。

* 展示了一部分在功能上与Redis有重叠的数据库服务器和缓存服务器，从这个表可以 看出Redis与这些数据库及软件之间的区别

  | 名称       | 类型                                    | 数据存储选项                                                 | 查询类型                                                     | 附加功能                                                     |
  | ---------- | --------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | Redis      | 使用内存存储 (in-memory)的非 关系数据库 | 字符串、列表、集合、散列 表、有序集合                        | 每种数据类型都有自 己的专属命令，另外还 有批量操作(bulk operation)和不完全 (partial)的事务支持 | 发布与订阅，主从复制 (master/slave replication), 持久化，脚本(存储过程， stored procedure) |
  | memcached  | 使用内存存储的键值缓存                  | 键值之间的映射                                               | 创建命令、读取命令、 更新命令、删除命令以 及其他几个命令     | 为提升性能而设的多线 程服务器                                |
  | MySQL      | 关系数据库                              | 每个数据库可以包含多个 表，每个表可以包含多个行； 可以处理多个表的视图 (view)；支持空间(spatial) 和第三方扩展 | SELECT > INSERT、 UPDATE、 DELETE、 函数、存储过程           | 支持ACID性质(需要使 用InnoDB),主从复制和 主主复制(master/master replication) |
  | PostgreSQL | 关系数据库                              | 每个数据库可以包含多个 表，每个表可以包含多个行； 可以处理多个表的视图；支 持空间和第三方扩展；支持 可定制类型 | SELECT、INSERT > UPDATE、 DELETE. 内置函数、自定义的存 储过程 | 支持ACID性质，主从复 制，由第三方支持的多主(multi-masterreplication) |
  | MongoDB    | 使用硬盘存储 (on-disk)的非关 系文档存储 | 每个数据库可以包含多个 表，每个表可以包含多个无 schema ( schema-less )的 BSON文档 | 创建命令、读取命令、 更新命令、删除命令、 条件査询命令等     | 支持 map-reduce 操作， 主从复制，分片，空间索 弓 I (spatial index) |

#####  附加特性

* 在使用类似Redis这样的内存数据库时，一个首先要考虑的问题就是“当服务器被关闭时， 服务器存储的数据将何去何从呢？ ” Redis拥有两种不同形式的持久化方法，它们都可以用小而紧凑的格式将存储在内存中的数据写入硬盘:第一种持久化方法为时间点转储(point-intime dump),转储操作既可以在“指定时间段内有指定数量的写操作执行”这一条件被满足时执行， 又可以通过调用两条转储到硬盘(dump-to.disk)命令中的任何一条来执行；第二种持久化方法 将所有修改了数据库的命令都写入一个只追加(append-only )文件里面，用户可以根据数据的重 要程度，将只追加写入设置为从不同步(sync)、每秒同步一次或者每写入一个命令就同步一次。
* 另外，尽管Redis的性能很好，但受限于Redis的内存存储设计，有时候只使用一台Redis 服务器可能没有办法处理所有请求。因此，为了扩展Redis的读性能，并为Redis提供故障转移 (failover)支持，Redis实现了主从复制特性:执行复制的从服务器会连接上主服务器，接收主服 务器发送的整个数据库的初始副本(copy);之后主服务器执行的写命令，都会被发送给所有连 接着的从服务器去执行，从而实时地更新从服务器的数据集。因为从服务器包含的数据会不断地 进行更新，所以客户端可以向任意一个从服务器发送读请求，以此来避免对主服务器进行集中式 的访问。我们将在第4章中更加深入地讨论Redis从服务器。

##### 使用Redis的理由

* 有memcached使用经验的读者可能知道，用户只能用APPEND命令将数据添加到已有字符 串的末尾。memcached的文档中声明，可以用APPEND命令来管理元素列表。这很好！用户可以 将元素追加到一个字符串的末尾，并将那个字符串当作列表来使用。但随后如何删除这些元素 呢？ memcached采用的办法是通过黑名单(blacklist)来隐藏列表里面的元素，从而避免对元素 执行读取、更新、写入(包括在一次数据库查询之后执行的memcached写入)等操作。相反地, Redis的LIST和SET允许用户直接添加或者删除元素。
* 使用Redis而不是memcached来解决问题，不仅可以让代码变得更简短、更易懂、更易 维护，而且还可以使代码的运行速度更快(因为用户不需要通过读取数据库来更新数据)。除 此之外，在其他许多情况下，Redis的效率和易用性也比关系数据库要好得多。
* 数据库的一个常见用法是存储长期的报告数据，并将这些报告数据用作固定时间范围内的聚 合数据(aggregates) 收集聚合数据的常见做法是:先将各个行插入一个报告表里面，之后再通 过扫描这些行来收集聚合数据，并根据收集到的聚合数据来更新聚合表中已有的那些行。之所以 使用插入行的方式来存储，是因为对于大部分数据库来说，插入行操作的执行速度非常快(插入 行只会在硬盘文件末尾进行写入)。不过，对表里面的行进行更新却是一个速度相当慢的操作， 因为这种更新除了会引起一次随机读(random read)之外，还可能会引起一次随机写(random write )o而在Redis里面，用户可以直接使用原子的(atomic)工NCR命令及其变种来计算聚合数 据，并且因为Redis将数据存储在内存里面)而且发送给Redis的命令请求并不需要经过典型的 查询分析器(parser)或者查询优化器(optimizer)进行处理，所以对Redis存储的数据执行随机 写的速度总是非常迅速的。
* 使用Redis而不是关系数据库或者其他硬盘存储数据库，可以避免写入不必要的临时数 据，也免去了对临时数据进行扫描或者删除的麻烦，并最终改善程序的性能。虽然上面列举 的都是一些简单的例子，但它们很好地证明了 “工具会极大地改变人们解决问题的方式”这 一点。
* 客观来讲，memcached也能用在这个简单的场景里，但使用Redis存储聚合数据有以下3个好处:首先， 使用Redis可以将彼此相关的聚合数据放在同一个结构里面，这样访问聚合数据就会变得更为容易；其 次，使用Redis可以将聚合数据放到有序集合里面，构建出一个实时的排行榜；最后，Redis的聚合数 据可以是整数或者浮点数，而memcached的聚合数据只能是整数。

#### Redis数据结构简介

* Redis可以存储键与5种不同数据结构类型之间的映射，这5种数 据结构类型分别为STRING (字符串)、LIST (列表)、SET (集合)、HASH (散列)和ZSET (有 序集合)。有一部分Redis命令对于这5种结构都是通用的，如DEL、TYPE、RENAME等；但也 有一部分Redis命令只能对特定的一种或者两种结构使用。

* 大部分程序员应该都不会对Redis的STRING、LIST. HASH这3种结构感到陌生，因 为它们和很多编程语言内建的字符串、列表和散列等结构在实现和语义(semantics)方面都 非常相似。有些编程语言还有集合数据结构，在实现和语义上类似于Redis的SET。ZSET在 某种程度上是一种Redis特有的结构，但是当你熟悉了它之后，就会发现它也是一种非常有 用的结构。

*  Redis提供的5种结构

  | 结构类型          | 结构存储的值                                                 | 结构的读写能力                                               |
  | ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | STRING            | 可以是字符串、整数或者浮点数                                 | 对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增(increment)或者自减(decrement) 操作 |
  | LIST              | 一个链表，链表上的每个节点都包含了 一个字符串                | 从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪(trim)；读取单个或者多个元素；根据值査找或者移除元素 |
  | SET               | 包含字符串的无序收集器(unordered collection),并且被包含的每个字符串都 是独一无二、各不相同的 | 添加、获取、移除单个元素；检査一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素 |
  | HASH              | 包含键值对的无序散列表                                       | 添加、获取、移除单个键值对；获取所有键值对                   |
  | ZSET (有序集合) | 字符串成员(member)与浮点数分值 (score)之间的有序映射，元素的排列顺 序由分值的大小决定 | 添加、获取、删除单个元素；根据分值范围(range) 或者成员来获取元素 |

##### Redis中的字符串

* Redis的字符串和其他编程语言或者其他键值存储提供的字符串非常相似。

* 字符串拥有一些和其他键值存储相似的命令，比如GET (获取值)、SET (设置值)和DEL (删除值)

  | 命令 | 行为                                                         |
  | ---- | ------------------------------------------------------------ |
  | GET  | 获取存储在给定键中的值                                       |
  | SET  | 设置存储在给定键中的值                                       |
  | DEL  | 删除存储在给定键中的值(这个命令可以用于所有类型);DEL命令将返回被 成功删除的值的数量 |

* 除了能够get、SET和DEL字符串值之外，Redis还提供了一些可以对字符串的其中一部分内容进行读取和写入的命令，以及一些能对字符串存储的数值执行自增或者自减操作的命令。

##### Redis中的列表

* Redis对链表(linked-list)结构的支持使得它在键值存储的世界中独树一帜。一个列表结构可以有序地存储多个字符串。

* Redis列表可执行的操作和很多编程语言里面的列表操作非常相似:LPUSH命令和RPUSH命令分别用于将元素推入列表的左端(left end )和右端(right end ); LPOP命令和RPOP命令分别用于从列表的左端和右端弹出元素；LINDEX命令用于获取列表在给定位置上的一个元素；LRANGE命令用于获取列表在给定范围上的所有元素。

* 列表命令

  | 命令   | 行为                                     |
  | ------ | ---------------------------------------- |
  | RPUSH  | 将给定值推入列表的右端                   |
  | LRANGE | 获取列表在给定范围上的所有值             |
  | LINDEX | 获取列表在给定位置上的单个元素           |
  | LPOP   | 从列表的左端弹出一个值，并返回被弹出的值 |

  * 使用 0 为范围的一 起始索引，-1 为范围的结束索引，可以取出 列表包含的所有元素
  * 在向列表推入新元素之后，该命令会返回列表当 前的长度。
  * 从列表里面弹出一个元素， 被弹出的元素将不再存在于列表。

* 即使Redis的列表只支持以上提到的几个命令，它也已经可以用来解决很多问题了，但Redis并没 有就此止步一除了上面提到的命令之外，Redis列表还拥有从列表里面移除元素的命令、将元素插入列表中间的命令、将列表修剪至指定长度(相当于从列表的其中一端或者两端移除元素)的命令，以及其他一些命令。

##### Redis 的集合

* Redis的集合和列表都可以存储多个字符串，它们之间的不同在于，列表可以存储多个相同的字符串，而集合则通过使用散列表来保证自己存储的每个字符串都是各不相同的(这些散列表只有键，但没有与键相关联的值)。

* 因为Redis的集合使用无序(unordered )方式存储元素，所以用户不能像使用列表那样，将元素推入集合的某一端，或者从集合的某一端弹岀元素。不过用户可以使用SADD命令将元素添加到集合，或者使用SREM 命令从集合里面移除元素。另外还可以通过SISMEMBER命令快速地检查一个元素是否已经存在于集合中，或者使用SMEMBERS命令获取集合包含的所有元素(如果集合包含的元素非常多， 那么SMEMBERS命令的执行速度可能会很慢，所以请谨慎地使用这个命令)。

* 集合命令

  | 命令      | 行为                                         |
  | --------- | -------------------------------------------- |
  | SADD      | 将给定元素添加到集合                         |
  | SMEMBERS  | 返回集合包含的所有元素                       |
  | SISMEMBER | 检査给定元素是否存在于集合中                 |
  | SREM      | 如果给定的元素存在于集合中，那么移除这个元素 |

* 跟字符串和列表一样，集合除了基本的添加操作和移除操作之外，还支持很多其他操作，比 如SINTER， SUNION、SDIFF这3个命令就可以分别执行常见的交集计算、并集计算和差集计算。第3章将对集合的相关命令进行更详细的介绍，另外第7章还会展示如何使用集合来解决多 个问题。不过别心急，因为在Redis提供的5种数据结构中，还有两种我们尚未了解，让我们先 来看看Redis的散列。

##### Redis 的散列

* Redis的散列可以存储多个键值对之间的映射。和字符串一样，散列存储的值既可以是字符串又可以是数字值，并且用户同样可以对散列存储的数字值执行自增操作或者自减操作。

* 散列在很多方面就像是一个微缩版的Redis,不少字符串命令都有相应的散列版本。

* 散列命令

  | 命令    | 行为                                     |
  | ------- | ---------------------------------------- |
  | HSET    | 在散列里面关联起给定的键值对             |
  | HGET    | 获取指定散列键的值                       |
  | HGETALL | 获取散列包含的所有键值对                 |
  | HDEL    | 如果给定键存在于散列里面，那么移除这个键 |
  * 在尝试添加键值对到散列的时候，命令会返回一个值来表示给定的键是否已经存在于散列里面。
  * 在删除键值对的时候，命令会返回一个值来表示给定的键在移除之前是否存在于散列里面。

##### Redis的有序集合

* 有序集合和散列一样，都用于存储键值对:有序 集合的键被称为成员(member ),每个成员都是各不相同的；而有序集合的值则被称为分值(score),分值必须为浮点数。有序集合是Redis里面唯一一个既可以 根据成员访问元素(这一点和散列一样)，又可以根据 分值以及分值的排列顺序来访问元素的结构。

* 和Redis的其他结构一样，用户可以对有序集合执行添加、移除和获取等操作

* 序集合命令

  | 命令          | 行为                                                       |
  | ------------- | ---------------------------------------------------------- |
  | ZADD          | 将一个带有给定分值的成员添加到有序集合里面                 |
  | ZRANGE        | 根据元素在有序排列中所处的位置，从有序集合里面获取多个元素 |
  | ZRANGEBYSCORE | 获取有序集合在给定分值范围内的所有元素                     |
  | ZREM          | 如果给定成员存在于有序集合，那么移除这个成员               |

  * 在尝试向有序集合添加元素 的时候，命令会返回新添加元 素的数量
  * 在获取有序集合包含的所有元素 时，多个元素会按照分值大小进 行排序
  * 在移除有序集合元素的时候，命令会返回被移除元素的数量。

#### 对文章进行投票

* 要构建一个文章投票网站，我们首先要做的就是为了这个网站设置一些数值和限制条件:如 果一篇文章获得了至少200张支持票(up vote ),那么网站就认为这篇文章是一篇有趣的文章； 假如这个网站每天发布1000篇文章，而其中的50篇符合网站对有趣文章的要求，那么网站要做的就是把这50篇文章放到文章列表前100位至少一天；另外，这个网站暂时不提供投反对票 (down vote )的功能 
* 为了产生一个能够随着时间流逝而不断减少的评分，程序需要根据文章的发布时间和当前时间来计算文章的评分，具体的计算方法为:将文章得到的支持票数量乘以一个常量，然后加上文章的发布时间，得出的结果就是文章的评分。
* 我们使用从UTC时区1970年1月1日到现在为止经过的秒数来计算文章的评分，这个值通常被称为Unix时间。之所以选择使用Unix时间，是因为在所有能够运行Redis的平台上面，使用编程语言获取这个值都是一件非常简单的事情。另外， 计算评分时与支持票数量相乘的常量为432,这个常量是通 过将一天的秒数(86 400 )除以文章展示一天所需的支持票 数量(200)得出的:文章每获得一张支持票，程序就需要 将文章的评分增加432分。
* 构建文章投票网站除了需要计算文章评分之外，还需要使用Redis结构存储网站上的各种信息。对于网站里的每篇文章，程序都使用一个散列来存储文章的标题、指向文章的网址、发布文章的用户、文章的发布时间、文章得到的投票数量等信息。
* 我们的文章投票网站将使用两个有序集合来有序地存储文章:第一个有序集合的成员为文章ID,分值为文章的发布时间；第二个有序集合的成员同样为文章 ID,而分值则为文章的评分。 通过这两个有序集合，网站既可以根据文章发布的先后顺序来展示文章，又可以根据文章评分的 高低来展示文章。
* 为了防止用户对同一篇文章进行多次投票，网站需要为每篇文章记录一个已投票用户名单。为此，程序将为每篇文章创建一个集合，并使用这个集合来存储所有已投票用户的ID
* 为了尽量节约内存，我们规定当一篇文章发布期满一周之后，用户将不能再对它进行投票，文章的评分将被固定下来，而记录文章已投票用户名单的集合也会被删除。
* 既然我们已经知道了网站计算文章评分的方法，也知道了网站存储数据所需的数据结构， 那么现在是时候实际地实现这个投票功能了！当用户尝试对一篇文章进行投票时，程序需要使用ZSCORE命令检查记录文章发布时间的有序集合，判断文章的发布时间是否未超过一周。如果文章仍然处于可以投票的时间范围之内，那么程序将使用SADD命令，尝试将用户添加到记录文章已投票用户名单的集合里面。如果添加操作执行成功的话，那么说明用户是第一次对这篇文章进行投票，程序将使用ZINCRBY命令为文章的评分增加432分(ZINCRBY命令用于对有序集合成员的分值执行自增操作)，并使用HINCRBY命令对散列记录的文章投票数量进行更新(ZINCRBY命令用于对散列存储的值执行自增操作)，代码清单1-6展示了投票功能的实现代码。

##### 文章投票功能

##### 发布并获取文章

* 发布一篇新文章首先需要创建一个新的文章ID,这项工作可以通过对一个计数器(counter) 执行INCR命令来完成。接着程序需要使用SADD将文章发布者的ID添加到记录文章已投票用户名单的集合里面，并使用EXPIRE命令为这个集合设置一个过期时间，让Redis在文章发布期满一周之后自动删除这个集合。之后，程序会使用HMSET命令来存储文章的相关信息，并执行 两个ZADD命令，将文章的初始评分(initial score )和发布时间分别添加到两个相应的有序集合里面。
* 好了，我们已经陆续实现了文章投票功能和文章发布功能，接下来要考虑的就是如何取出评分最高的文章以及如何取出最新发布的文章了。为了实现这两个功能，程序需要先使用ZREVRANGE 命令取出多个文章ID,然后再对每个文章ID执行一次HGETALL命令来取出文章的详细信息，这个 方法既可以用于取出评分最高的文章，又可以用于取出最新发布的文章。这里特别要注意的一点是, 因为有序集合会根据成员的分值从小到大地排列元素，所以使用ZREVRANGE命令，以“分值从大 到小”的排列顺序取岀文章ID才是正确的做法，代码清单1.8展示了文章获取功能的实现函数。

##### 对文章进行分组

* 群组功能由两个部分组成，一个部分负责记录文章属于哪个群组，另一个部分负责取出群组里面的文章。为了记录各个群组都保存了哪些文章，网站需要为每个群组创建一个集合，并将所有同属一个群组的文章ID都记录到那个集合里面。
* 初看上去，可能会有读者觉得使用集合来记录群组文章并没有多大用处。到目前为止，读者 只看到了集合结构检查某个元素是否存在的能力，但实际上Redis不仅可以对多个集合执行操作， 甚至在一些情况下，还可以在集合和有序集合之间执行操作。
* 为了能够根据评分对群组文章进行排序和分页(paging),网站需要将同一个群组里面的所有文章都按照评分有序地存储到一个有序集合里面。Redis的ZINTERSTORE命令可以接受多个集合和多个有序集合作为输入，找出所有同时存在于集合和有序集合的成员，并以几种不同的方式来合并(combine )这些成员的分值(所有集合成员的分值都会被视为是1 )。对于我们的文章投票网站来说，程序需要使用ZINTERSTORE命令选出相同成员中最大的那个分值来作为交集成员的分值:取决于所使用的排序选项，这些分值既可以是文章的评分，也可以是文章的发布时间。
* 通过对存储群组文章的集合和存储文章评分的有序集合执行ZINTERSTORE命令，程序可以得到按照文章评分排序的群组文章；而通过对存储群组文章的集合和存储文章发布时间的有序集合执行ZINTERSTORE命令，程序则可以得到按照文章发布时间排序的群组文章。如果群组包含的文章非常多，那么执行ZINTERSTORE命令就会比较花时间。
* 有些网站只允许用户将文章放在一个或者两个群组里面(其中一个是“所有文章”群组， 另一个是最适合文章的群组)。在这种情况下，最好直接将文章所在的群组记录到存储文章信息的散列里面。但是在这个示例里面，我们构建的文章投票网站允许一篇文章同时属于多个群组(比如一篇文章可以同时属于“编程”和“算法”两个群组)，所以对于一篇同时属于多个群组的文章来说，更新文章的评分意味着程序需要对文章所属的全部群组执行自增操作。在这种情况下，如果一篇文章同时属于很多个群组，那么更新文章评分这一操作可能 会变得相当耗时。

##### 数据结构选择

* ```
  1. 用于保存文章信息的hash结构
  2. 用于保存文章两种排序方式的 zset 结构
  	1. 创建时间排序(分数为创建时间)
  	2. 投票数的排序(分数为投票数)
  3. 用于保存某文章已投票人数的无序集合
  	1. 防止同一用户多次投票
  	2. 用其过期时间判断是否可投票
  4. 用于保存文章分组的无序集合
  ```

#### 小结

* 对Redis进行了初步的介绍，说明了 Redis与其他数据库的相同之处和不同之处，以及可能会使用Redis的理由。希望向读者传达这样一个概念:Redis是一个可以用来解决问题的工具，它既拥有其他数据库不具备的数据结构，又拥有内存存储(这使得Redis的速度非常快)、远程(这使得Redis 可以与多个客户端和服务器进行连接)、持久化(这使得服务器可以在重启之后仍然保持重启之前的数据)和可扩展(通过主从复制和分片)等多个特性，这使得用户可以以熟悉的方式为各种不同的问题构建解决方案。

