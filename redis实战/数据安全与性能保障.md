#### 持久化选项

* Redis提供了两种不同的持久化方法来将数据存储到硬盘里面。一种方法叫快照(snapshotting ), 它可以将存在于某一时刻的所有数据都写入硬盘里面。另一种方法叫只追加文件(append-only file, AOF),它会在执行写命令时，将被执行的写命令复制到硬盘里面。这两种持久化方法既可以同 时使用，又可以单独使用，在某些情况下甚至可以两种方法都不使用，具体选择哪种持久化方法 需要根据用户的数据以及应用来决定。

* 将内存中的数据存储到硬盘的一个主要原因是为了在之后重用数据，或者是为了防止系统 故障而将数据备份到一个远程位置。另外，存储在Redis里面的数据有可能是经过长时间计算 得出的，或者有程序正在使用Redis存储的数据进行计算，所以用户会希望自己可以将这些数 据存储起来以便之后使用，这样就不必再重新计算了。对于一些Redis应用来说，“计算”可能 只是简单地将另一个数据库的数据复制到Redis里面(2.4节中就介绍过这样的例子)，但对 于另外一些Redis应用来说，Redis存储的数据可能是根据数十亿行日志进行聚合分析得出 的结果。

* 两组不同的配置选项控制着Redis将数据写入硬盘里面的方式

  ```
  // 快照持久化选项。
  save 60 1000 
  stop-writes-on-bgsave-error no 
  rdbcompression yes 
  dbfilename dump.rdb
  
  // AOF持久化选项。
  appendonly no
  appendfsync everysec 
  no-appendfsync-on-rewrite no 
  auto-aof-rewrite-percentage 100 
  auto-aof-rewrite-min-size 64mb
  
  // 共享选项，这个选项决定 了快照文件和AOF文件的保存位置。
  dir ./
  ```

  代码清单最开头的几个选项和快照持久化有关，比如:如何命名硬盘上的快照文件、 多久执行一次自动快照操作、是否对快照文件进行压缩，以及在创建快照失败后是否仍然继续 执行写命令。代码清单的第二组选项用于配置AOF子系统(subsystem ):这些选项告诉Redis 是否使用AOF持久化、多久才将写入的内容同步到硬盘、在对AOF进行压缩(compaction) 的时候能否执行同步操作，以及多久执行一次AOF压缩。

##### 快照持久化

* Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。在创建快照 之后，用户可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器 副本，还可以将快照留在原地以便重启服务器时使用。

* 根据配置，快照将被写入dbfilename选项指定的文件里面，并储存在dir选项指定的路 径上面。如果在新的快照文件创建完毕之前，Redis、系统或者硬件这三者之中的任意一个崩溃 了，那么Redis将丢失最近一次创建快照之后写入的所有数据。
* 举个例子，假设Redis目前在内存里面存储了 10GB 的数据，上一个快照是在下午2:35开 始创建的，并且已经创建成功。下午3:06时，Redis又开始创建新的快照，并且在下午3:08快 照文件创建完毕之前，有35个键进行了更新。如果在下午3:06至下午3:08期间，系统发生崩 溃，导致Redis无法完成新快照的创建工作，那么Redis将丢失下午2:35之后写入的所有数据。 另一方面，如果系统恰好在新的快照文件创建完毕之后崩溃，那么Redis将只丢失35个键的更新 数据。
* 创建快照的办法有以下几种。
  * 客户端可以通过向Redis发送BGSAVE命令来创建一个快照。对于支持BGSAVE命令的 平台来说(基本上所有平台都支持，除了 Windows平台)，Redis会调用fork来创建一 个子进程，然后子进程负责将快照写入硬盘，而父进程则继续处理命令请求。
  * 客户端还可以通过向Redis发送SAVE命令来创建一个快照，接到SAVE命令的Redis服 务器在快照创建完毕之前将不再响应任何其他命令。SAVE命令并不常用，我们通常 只会在没有足够内存去执行BGSAVE命令的情况下，又或者即使等待持久化操作执 行完毕也无所谓的情况下，才会使用这个命令。
  * 如果用户设置了 save配置选项，比如save 60 10000,那么从Redis最近一次创建 快照之后开始算起，当“60秒之内有10 000次写入”这个条件被满足时，Redis就会自动 触发BGSAVE命令。如果用户设置了多个save配置选项，那么当任意一个save配置 选项所设置的条件被满足时，Redis就会触发一次BGSAVE命令。
  * 当Redis通过SHUTDOWN命令接收到关闭服务器的请求时，或者接收到标准TERM信号 时，会执行一个SAVE命令，阻塞所有客户端，不再执行客户端发送的任何命令，并在 SAVE命令执行完毕之后关闭服务器。
  * 当一个Redis服务器连接另一个Redis服务器，并向对方发送SYNC命令来开始一次复 制操作的时候，如果主服务器目前没有在执行BGSAVE操作，或者主服务器并非刚刚执 行完BGSAVE操作，那么主服务器就会执行BGSAVE命令。
* 在只使用快照持久化来保存数据时，一定要记住:如果系统真的发生崩溃，用户将丢失最 近一次生成快照之后更改的所有数据。因此，快照持久化只适用于那些即使丢失一部分数据也 不会造成问题的应用程序
  * 当一个进程创建子进程的时候，底层的操作系统会创建该进程的一个副本。在Unix和类Unix系统上面， 创建子进程的操作会进行如下优化:在刚开始的时候，父子进程共享相同的内存，直到父进程或者子进 程对内存进行了写入之后，对被写入内存的共享才会结束。

###### 个人开发

* 在个人开发服务器上面，主要考虑的是尽可能地降低快照持久化带来的资源消耗。基于这个 原因以及对自己硬件的信任，我只设置了 save 900 1这一条规则。其中save选项告知Redis, 它应该根据这个选项提供的两个值来执行BGSAVE操作。在这个规则设置下，如果服务器距离上 次成功生成快照已经超过了 900秒(也就是15分钟)，并且在此期间执行了至少一次写入操作， 那么Redis就会自动开始一次新的BGSAVE操作。
* 如果你打算在生产服务器中使用快照持久化并存储大量数据，那么你的开发服务器最好能 够运行在与生产服务器相同或者相似的硬件上面，并在这两个服务器上使用相同的save选项、 存储相似的数据集并处理相近的负载量。把开发环境设置得尽量贴近生产环境，有助于判断快 照是否生成得过于频繁或者过于稀少(过于频繁会浪费资源，而过于稀少则带有丢失大量数据 的隐患)

###### 对日志进行聚合计算

* 在对日志文件进行聚合计算或者对页面浏览量进行分析的时候，我们唯一需要考虑的就 是:如果Redis因为崩溃而未能成功创建新的快照，那么我们能够承受丢失多长时间以内产 生的新数据。如果丢失一个小时之内产生的数据是可以被接受的，那么可以使用配置值save 3600 1( 3600为一小时的秒数)。在决定好了持久化配置值之后，另一个需要解决的问题就是如何恢复因为故障而被中断的日志处理操作。
* 在进行数据恢复时，首先要做的就是弄清楚我们丢失了哪些数据。为了弄明白这一点，我们 需要在处理日志的同时记录被处理日志的相关信息。

###### 大数据

* 当Redis存储的数据量只有几个GB的时候，使用快照来保存数据是没有问题的。Redis 会创建子进程并将数据保存到硬盘里面，生成快照所需的时间比你读这句话所需的时间还 要短。但随着Redis占用的内存越来越多，BGSAVE在创建子进程时耗费的时间也会越来越 多。如果Redis的内存占用量达到数十个GB,并且剩余的空闲内存并不多，或者Redis运 行在虚拟机(virtual machine )上面，那么执行BGSAVE可能会导致系统长时间地停顿，也 可能引发系统大量地使用虚拟内存(virtual memory ),从而导致Redis的性能降低至无法使 用的程度。
* 执行BGSAVE而导致的停顿时间有多长取决于Redis所在的系统:对于真实的硬件、VMWare 虚拟机或者KVM虚拟机来说，Redis进程每占用一个GB的内存，创建该进程的子进程所需的 时间就要增加10〜20毫秒；而对于Xen虚拟机来说，根据配置的不同，Redis进程每占用一个 GB的内存，创建该进程的子进程所需的时间就要增加200〜300毫秒。因此，如果我们的Redis 进程占用了 20 GB的内存，那么在标准硬件上运行BGSAVE所创建的子进程将导致Redis停顿 200〜400毫秒；如果我们使用的是Xen虚拟机(亚马逊EC2和其他几个云计算供应商都使用这 种虚拟机)，那么相同的创建子进程操作将导致Redis停顿4〜6秒。用户必须考虑自己的应用程 序能否接受这种停顿。
* 为了防止Redis因为创建子进程而出现停顿，我们可以考虑关闭自动保存，转而通过手动发 送BGSAVE或者SAVE来进行持久化。手动发送BGSAVE 一样会引起停顿，唯一不同的是用户可 以通过手动发送BGSAVE命令来控制停顿出现的时间。另一方面，虽然SAVE会一直阻塞Redis 直到快照生成完毕，但是因为它不需要创建子进程，所以就不会像BGSAVE 一样因为创建子进程 而导致Redis停顿；并且因为没有子进程在争抢资源，所以SAVE创建快照的速度会比BGSAVE 创建快照的速度要来得更快一些。
* 根据我的个人经验，在一台拥有68 GB内存的Xen虚拟机上面，对一个占用50 GB内存的 Redis服务器执行BGSAVE命令的话，光是创建子进程就需要花费15秒以上，而生成快照则需要 花费15〜20分钟；但使用SAVE只需要3〜5分钟就可以完成快照的生成工作。因为我的应用 程序只需要每天生成一次快照，所以我写了一个脚本，让它在每天凌晨3点停止所有客户端对 Redis的访问，调用SAVE命令并等待该命令执行完毕，之后备份刚刚生成的快照文件，并通知 客户端继续执行操作。
* 如果用户能够妥善地处理快照持久化可能会带来的大量数据丢失，那么快照持久化对用户来 说将是一个不错的选择，但对于很多应用程序来说，丢失15分钟、1小时甚至更长时间的数据 都是不可接受的，在这种情况下，我们可以使用AOF持久化来将存储在内存里面的数据尽快地 保存到硬盘里面。

##### AOF持久化

* 简单来说，AOF持久化会将被执行的写命令写到AOF文件的末尾，以此来记录数据发生的变化。因此，Redis只要从头到尾重新执行一次AOF文件包含的所有写命令，就可以恢复AOF文件所记录的数据集。AOF持久化可以通过设置 `appendonly yes` 配置选项来打开。
* 文件同步 在向硬盘写入文件时，至少会发生3件事。当调用 `file.write ()` 方法(或者其他编程语言里面的类似操作)对文件进行写入时，写入的内容首先会被存储到缓冲区，然后操作系统会在将来的某个时候将缓冲区存储的内容写入硬盘，而数据只有在被写入硬盘之 后，才算是真正地保存到了硬盘里面。用户可以通过调用 `file.flush()` 方法来请求操作系统尽快地将缓冲区存储的数据写入硬盘里，但具体何时执行写入操作仍然由操作系统决定。除此之外，用户还可以命令操作系统将文件(`sync`)到硬盘，同步操作会一直阻塞直到指定的文件被写入硬盘为止。当同步操作执行完毕之后，即使系统出现故障也不会对被同步的文件造成任何影响。

* appendfsync选项及同步频率

  | 选 项    |                           同步频率                           |
  | -------- | :----------------------------------------------------------: |
  | always   | 每个Redis写命令都要同步写入硬盘。这样做会严重降低Redis的速度 |
  | everysec |        每秒执行一次同步，显式地将多个写命令同步到硬盘        |
  | no       |               让操作系统来决定应该何时进行同步               |
  * 如果用户使用appendfsync always选项的话，那么每个Redis写命令都会被写入硬盘， 从而将发生系统崩溃时出现的数据丢失减到最少。不过遗憾的是，因为这种同步策略需要对硬盘 进行大量写入，所以Redis处理命令的速度会受到硬盘性能的限制:转盘式硬盘(spinning disk) 在这种同步频率下每秒只能处理大约200个写命令，而固态硬盘(solid.state drive, SSD )每秒 大概也只能处理几万个写命令。
  * 警告:固态硬盘和appendfsync always 使用固态硬盘的用户请谨慎使用appendfsync always选项，因为这个选项让Redis每次只写入一个命令，而不是像其他appendfsync选项那 样一次写入多个命令，这种不断地写入少量数据的做法有可能会引发严重的写入放大(write ampUfication )问题，在某些情况下甚至会将固态硬盘的寿命从原来的几年降低为几个月。
  * 为了兼顾数据安全和写入性能，用户可以考虑使用appendfsync everysec选项，让Redis 以每秒一次的频率对AOF文件进行同步。Redis每秒同步一次AOF文件时的性能和不使用任何 持久化特性时的性能相差无几，而通过每秒同步一次AOF文件，Redis可以保证，即使出现系统 崩溃，用户也最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会 优雅地放慢自己的速度以便适应硬盘的最大写入速度。
  * 最后，如果用户使用appendfsync no选项，那么Redis将不对AOF文件执行任何显式 的同步操作，而是由操作系统来决定应该在何时对AOF文件进行同步。这个选项在一般情况下 不会对Redis的性能带来影响，但系统崩溃将导致使用这种选项的Redis服务器丢失不定数量的 数据。另外，如果用户的硬盘处理写入操作的速度不够快的话，那么当缓冲区被等待写入硬盘的 数据填满时，Redis的写入操作将被阻塞，并导致Redis处理命令请求的速度变慢。因为这个原因， 一般来说并不推荐使用appendfsync no选项，在这里介绍它只是为了完整列举appendfsync 选项可用的3个值。

* 虽然AOF持久化非常灵活地提供了多种不同的选项来满足不同应用程序对数据安全的不同 要求，但AOF持久化也有缺陷——那就是AOF文件的体积大小。

##### 重写/压缩AOF文件

* AOF持久化既可以将丢失数据的时间窗口降低至1秒(甚至不丢失任何数据)，又可以在极短的时间内完成定期的持久 化操作，那么我们有什么理由不使用AOF持久化呢？但是这个问题实际上并没有那么简单，因 为Redis会不断地将被执行的写命令记录到AOF文件里面，所以随着Redis不断运行，AOF文 件的体积也会不断增长，在极端情况下，体积不断增大的AOF文件甚至可能会用完硬盘的所有 可用空间。还有另一个问题就是，因为Redis在重启之后需要通过重新执行AOF文件记录的所 有写命令来还原数据集，所以如果AOF文件的体积非常大，那么还原操作执行的时间就可能会非常长。
* 为了解决AOF文件体积不断增大的问题，用户可以向Redis发送BGREWRITEAOF命令，这 个命令会通过移除AOF文件中的冗余命令来重写(rewrite) AOF文件，使AOF文件的体积变得 尽可能地小。BGREWRITEAOF的工作原理和BGSAVE创建快照的工作原理非常相似:Redis会创 建一个子进程，然后由子进程负责对AOF文件进行重写。因为AOF文件重写也需要用到子进程， 所以快照持久化因为创建子进程而导致的性能问题和内存占用问题，在AOF持久化中也同样存 在。更糟糕的是，如果不加以控制的话，AOF文件的体积可能会比快照文件的体积大好几倍， 在进行AOF重写并删除旧AOF文件的时候，删除一个体积达到数十GB大的旧AOF文件可能 会导致操作系统挂起(hang)数秒。
* 跟快照持久化可以通过设置save选项来自动执行BGSAVE 一样，AOF持久化也可以通过 auto-aof-rewrite-percentage 选项和 auto-aof-rewrite-min-size来自动执行 BGREWRITEAOF。 举个例子，假设用户对 Redis 设置了auto-aof-rewrite-percentage 100 和 auto-aof-rewrite-min-size 64mb,并且启用了 AOF 持久化，那么当 AOF 文件的体积大于64 MB,并且AOF文件的体积比上一次重写之后的体积大了至少一倍(100% )的时 候，Redis将执行BGREWRITEAOF。如果AOF重写执行得过于频繁的话，用户可以考虑将auto-aof-rewrite-percentage	的值设置为100以上，这种做法可以让Redis在AOF文件的体积变得更大之后才执行重写操作，不过也会让Redis在启动时还原数据集所需的时间变得更长。
* 无论是使用AOF持久化还是快照持久化，将数据持久化到硬盘上都是非常有必要的，但除 了进行持久化之外，用户还必须对持久化所得的文件进行备份(最好是备份到多个不同的地方)， 这样才能尽量避免数据丢失事故发生。如果条件允许的话，最好能将快照文件和最新重写的AOF 文件备份到不同的服务器上面。
* 通过使用AOF持久化或者快照持久化，用户可以在系统重启或者崩溃的情况下仍然保留数 据。随着负载量的上升，或者数据的完整性变得越来越重要时，用户可能需要使用复制特性。

#### 复制

* 对于有扩展平台以适应更高负载经验的工程师和管理员来说，复制(replication )是不可或 缺的。复制可以让其他服务器拥有一个不断地更新的数据副本，从而使得拥有数据副本的服务器 
* 可以用于处理客户端发送的读请求。关系数据库通常会使用一个主服务器(master)向多个从服务器(slave)发送更新，并使用从服务器来处理所有读请求。Redis也釆用了同样的方法来实现自己的复制特性，并将其用作扩展性能的一种手段。
* 尽管Redis的性能非常优秀，但它也会遇上没办法快速地处理请求的情况，特别是在对集合 和有序集合进行操作的时候，涉及的元素可能会有上万个甚至上百万个，在这种情况下，执行操 作所花费的时间可能需要以秒来进行计算，而不是毫秒或者微秒。但即使一个命令只需要花费 10毫秒 就能完成，单个Redis实例(instance ) 1秒也只能处理100个命令。
* SUNIONSTORE命令的性能 作为对Redis性能的一个参考，在主频为2.4 GHz的英特尔酷睿2处理器 上，对两个分别包含10000个元素的集合执行SUNIONSTORE命令并产生一个包含20 000个元 素的结果集合，需要花费Redis七八毫秒的时间。
* 在需要扩展读请求的时候，或者在需要写入临时数据的时候(第7章对此有详细的介绍)， 用户可以通过设置额外的Redis从服务器来保存数据集的副本。在接收到主服务器发送的数据初 始副本(initial copy of the data )之后，客户端每次向主服务器进行写入时，从服务器都会实时地 得到更新。在部署好主从服务器之后，客户端就可以向任意一个从服务器发送读请求了，而不必 再像之前一样，总是把每个读请求都发送给主服务器(客户端通常会随机地选择使用哪个从服 务器，从而将负载平均分配到各个从服务器上)。

##### 对Redis的复制相关选项进行配置

* 当从服务器连接主服务器的时候，主服务器会执行BGSAVE操作。 因此为了正确地使用复制特性，用户需要保证主服务器已经正确地设置了dir选项和dbfilename选项，并且这两个选项所指示的路径和文件对于Redis进程来说都是可写的(writable )
* 尽管有多个不同的选项可以控制从服务器自身的行为，但开启从服务器所必须的选项只有 `slaveof host port`。如果用户在启动Redis服务器的时候，指定了一个包含slaveof host port 选项的配置文件，那么Redis服务器将根据该选项给定的IP地址和端口号来连接主服务器。对于 一个正在运行的Redis服务器，用户可以通过发送 `SLAVEOF no one` 命令来让服务器终止复制 操作，不再接受主服务器的数据更新；也可以通过发送 `SLAVEOF host port` 命令来让服务器 开始复制一个新的主服务器。
* 开启Redis的主从复制特性并不需要进行太多的配置，但了解Redis服务器是如何变成主服 务器或者从服务器的，对于我们来说将是非常有用的和有趣的过程。

##### Redis复制的启动过程

* 从服务器在连接一个主服务器的时候，主服务器会创建一个快照文件并 将其发送至从服务器，但这只是主从复制执行过程的其中一步。

* 表4-2 从服务器连接主服务器时的步骤

  | 步 骤 | 主服务器操作                                                 | 从服务器操作                                                 |
  | ----- | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | 1     | (等待命令进入)                                             | 连接(或者重连接)主服务器，发送SYNC命令                     |
  | 2     | 开始执行BGSAVE,并使用缓冲区记录BGSAVE 之后执行的所有写命令   | 根据配置选项来决定是继续使用现有的数据(如果有 的话)来处理客户端的命令请求，还是向发送请求的客户端返回错误 |
  | 3     | BGSAVE执行完毕，向从服务器发送快照文件， 并在发送期间继续使用缓冲区记录被执行的写命令 | 丢弃所有旧数据(如果有的话)，开始载入主服务器发来的快照文件 |
  | 4     | 快照文件发送完毕，开始向从服务器发送存储 在缓冲区里面的写命令 | 完成对快照文件的解释操作，像往常一样开始接受 命令请求        |
  | 5     | 缓冲区存储的写命令发送完毕；从现在开始， 每执行一个写命令，就向从服务器发送相同的写命令 | 执行主服务器发来的所有存储在缓冲区里面的写命令；并从现在开始，接收并执行主服务器传来的每个写命令 |

* Redis在复制进行期间也会尽可能地处理接收到的命令请求， 但是，如果主从服务器之间的网络带宽不足，或者主服务器没有足够的内存来创建子进程和创建 记录写命令的缓冲区，那么Redis处理命令请求的效率就会受到影响。因此，尽管这并不是必须 的，但在实际中最好还是让主服务器只使用50%〜65%的内存，留下30%〜45%的内存用于执行 BGSAVE命令和创建记录写命令的缓冲区。

* 设置从服务器的步骤非常简单，用户既可以通过配置选项SLAVEOF host port来将一个 Redis服务器设置为从服务器，又可以通过向运行中的Redis服务器发送SLAVEOF命令来将其 设置为从服务器。如果用户使用的是SLAVEOF配置选项，那么Redis在启动时首先会载入当前 可用的任何快照文件或者AOF文件，然后连接主服务器并执行表4.2所示的复制过程。如果用 户使用的是SLAVEOF命令，那么Redis会立即尝试连接主服务器，并在连接成功之后，开始上表所示的复制过程。

* 从服务器在进行同步时，会清空自己的所有数据。因为有些用户在第一次使用从服务器时会忘记这件事，所以这里要特别提醒一下:从服务器在与主服务器进行初始连接时，数据库中原有的所有数据都将丢失，并被替换成主服务器发来的数据

* 警告:Redis不支持主主复制(master-master replication) 因为Redis允许用户在服务器启动之后使用SLAVEOF命令来设置从服务器选项(slaving options ),所以可能会有读者误以为可以 通过将两个Redis实例互相设置为对方的主服务器来实现多主复制(multi-master replication ) (甚至可能会在一个循环里面将多个实例互相设置为主服务器)。遗憾的是，这种做法是行不通的:被互相设置为主服务器的两个Redis实例只会持续地占用大量处理器资源并且连续不断地尝试 与对方进行通信，根据客户端连接的服务器的不同，客户端的请求可能会得到不一致的数据，或者完全得不到数据。

* 当一个从服务器连接一个已有的主服务器时，有时可以重用已有的快照文件

  | 当有新的从服务器连接主服务器时       | 主服务器的操作                                               |
  | ------------------------------------ | ------------------------------------------------------------ |
  | 上表的步骤3尚未执行                  | 所有从服务器都会接收到相同的快照文件和相同的缓冲区写命令     |
  | 上表的步骤3正在执行或者已经执行 完毕 | 当主服务器与较早进行连接的从服务器执行完复制所需的5个步骤之后， 主服务器会与新连接的从服务器执行一次新的步骤1至步骤5 |

* 在大部分情况下，Redis都会尽可能地减少复制所需的工作，然而，如果从服务器连接 主服务器的时间并不凑巧，那么主服务器就需要多做一些额外的工作。另一方面，当多个 从服务器同时连接主服务器的时候，同步多个从服务器所占用的带宽可能会使得其他命令 请求难以传递给主服务器，与主服务器位于同一网络中的其他硬件的网速可能也会因此而降低。

##### 主从链

* 有些用户发现，创建多个从服务器可能会造成网络不可用——当复制需要通过互联网进行或 者需要在不同数据中心之间进行时，尤为如此。因为Redis的主服务器和从服务器并没有特别不 同的地方，所以从服务器也可以拥有自己的从服务器，并由此形成主从链(master/slave chaining )

* 从服务器对从服务器进行复制在操作上和从服务器对主服务器进行复制的唯一区别在于， 如果从服务器X拥有从服务器匕那么当从服务器X在执行表4.2中的步骤4时，它将断开与从 服务器V的连接，导致从服务器丫需要重新连接并重新同步(resync )。

* 当读请求的重要性明显高于写请求的重要性，并且读请求的数量远远超出一台Redis服务器 可以处理的范围时，用户就需要添加新的从服务器来处理读请求。随着负载不断上升，主服务器 可能会无法快速地更新所有从服务器，或者因为重新连接和重新同步从服务器而导致系统超载。 为了缓解这个问题，用户可以创建一个由Redis主从节点(master/slave node )组成的中间层来分 担主服务器的复制工作

  ![image](./imgs/1.png)

  尽管主从服务器之间并不一定要像图4-1那样组成一个树状结构，但记住并理解这种树状结 构对于Redis复制来说是可行的(possible)并且是合理的(reasonable)将有助于读者理解之后 的内容。本书在前面的4.1.2节中曾经介绍过，AOF持久化的同步选项可以控制数据丢失的时 间长度:通过将每个写命令同步到硬盘里面，用户几乎可以不损失任何数据(除非系统崩溃或者 硬盘驱动器损坏)，但这种做法会对服务器的性能造成影响；另一方面，如果用户将同步的频率 设置为每秒一次，那么服务器的性能将回到正常水平，但故障可能会造成1秒的数据丢失。通过 同时使用复制和AOF持久化，我们可以将数据持久化到多台机器上面。

  为了将数据保存到多台机器上面，用户首先需要为主服务器设置多个从服务器，然后对每个 从服务器设置appendonly yes选项和appendfsync everysec选项(如果有需要的话， 也可以对主服务器进行相同的设置)，这样的话，用户就可以让多台服务器以每秒一次的频率将 数据同步到硬盘上了。但这还只是第一步:因为用户还必须等待主服务器发送的写命令到达从 服务器，并且在执行后续操作之前，检查数据是否已经被同步到了硬盘里面。

##### 检验硬盘写入

* 为了验证主服务器是否已经将写数据发送至从服务器，用户需要在向主服务器写入真正的数据之后，再向主服务器写入一个唯一的虚构值(unique dummy value ),然后通过检查虚构值是否存在 于从服务器来判断写数据是否已经到达从服务器，这个操作很容易就可以实现。另一方面，判断数 据是否已经被保存到硬盘里面则要困难得多。对于每秒同步一次AOF文件的Redis服务器来说， 用户总是可以通过等待1秒来确保数据已经被保存到硬盘里面；但更节约时间的做法是，检查 INFO命令的输出结果中aof_pending_bio_fsync属性的值是否为0,如果是的话，那么就表 示服务器已经将已知的所有数据都保存到硬盘里面了。在向主服务器写入数据之后，用户可以将主服务器和从服务器的连接作为参数。
* INFO命令中的其他信息INFO命令提供了大量的与Redis服务器当前状态有关的信息，比如内存 占用量、客户端连接数、每个数据库包含的键的数量、上一次创建快照文件之后执行的命令数量， 等等。总的来说，INFO命令对于了解Redis服务器的综合状态非常有帮助，网上有很多资源都对 INFO命令进行了详细的介绍。

#### 处理系统故障

* 用户必须做好相应的准备来应对Redis的系统故障。本章在系统故障这主题上花费了大量的篇 幅，这是因为如果我们决定要将Redis用作应用程序唯一的数据存储手段，那么就必须确保Redis不 会丢失任何数据。跟提供了 ACID 保证的传统关系数据库不同，在使用Redis为后端构建应用程序的时候，用户需要多做一些工作才能保证数据的一致性。Redis是一个软件，它运行在硬件之 上，即使软件和硬件都设计得完美无瑕，也有可能会出现停电、发电机因为燃料耗尽而无法发 电或者备用电池电量消尽等情况。
* ACID 是指原子性(atomicity)、一致性(consistency)、隔离性(isolation )和耐久性(durability ),如果 一个数据库想要实现可靠的数据事务，那么它就必须保证ACID性质。

##### 验证快照文件和AOF文件

* 无论是快照持久化还是AOF持久化，都提供了在遇到系统故障时进行数据恢复的工具。Redis 提供了两个命令行程序`redis-check-aof` 和 `redis-check-dump` ,它们可以在系统故障发 生之后，检查AOF文件和快照文件的状态，并在有需要的情况下对文件进行修复。在不给定任 何参数的情况下运行这两个程序，就可以看见它们的基本使用方法
* 如果用户在运行redis-check-aof程序时给定了--fix参数，那么程序将对AOF文件进行 修复。程序修复AOF文件的方法非常简单:它会扫描给定的AOF文件，寻找不正确或者不完整的 命令，当发现第一个出错命令的时候，程序会删除出错的命令以及位于出错命令之后的所有命令， 只保留那些位于出错命令之前的正确命令。在大多数情况下，被删除的都是AOF文件末尾的不完整 的写命令。
* 遗憾的是，目前并没有办法可以修复出错的快照文件。尽管发现快照文件首个出现错误的 地方是有可能的，但因为快照文件本身经过了压缩，而出现在快照文件中间的错误有可能会导 致快照文件的剩余部分无法被读取。因此，用户最好为重要的快照文件保留多个备份，并在进 行数据恢复时，通过计算快照文件的SHA1散列值和SHA256散列值来对内容进行验证。(当 今的Linux平台和Unix平台都包含类似shalsum和sha256sum这样的用于生成和验证散列 值的命令行程序。)
* 校验和(checksum)与散列值(hash):  从2.6版本开始，Redis会在快照文件中包含快照文件自 身的CRC64校验和。CRC校验和对于发现典型的网络传输错误和硬盘损坏非常有帮助，而SHA加 密散列值则更擅长于发现文件中的任意错误(arbitrary error)0简单来说，用户可以翻转文件中任意 数量的二进制位，然后通过翻转文件最后64个二进制位的一个子集(subset)来产生与原文件相同 的CRC64校验和。而对于SHA1和SHA256,目前还没有任何已知的方法可以做到这一点。
* 在了解了如何验证持久化文件是否完好无损，并且在有需要时对其进行修复之后，我们接下 来要考虑的就是如何更换出现故障的Redis服务器。

##### 更换故障主服务器

* 在运行一组同时使用复制和持久化的Redis服务器时，用户迟早都会遇上某个或某些Redis 服务器停止运行的情况。造成故障的原因可能是硬盘驱动器岀错、内存出错或者电量耗尽，但无 论服务器因为何种原因出现故障，用户最终都要对发生故障的服务器进行更换。
* 假设A、B两台机器都运行着Redis,其中机器A的Redis为主服务器，而机器B的Redis 为从服务器。不巧的是，机器A刚刚因为某个暂时无法修复的故障而断开了网络连接，因此用 户决定将同样安装了 Redis的机器C用作新的主服务器。
  * 更换服务器的计划非常简单:首先向机器B发送一个SAVE命令，让它创建一个新的快照文 件，接着将这个快照文件发送给机器C,并在机器C上面启动RediSo最后，让机器B成为机器 C的从服务器。在这些命令当中，比较有趣的要数在机器B上运行的SAVE命令，以及将机器 B设置为机器C的从服务器的SLAVEOF命令。因为机器B原本就是一个从服务器，所以我们的客户端不能对它进行写入，并且在机器B执行快照操 作之后，我们的客户端也不会与其他试图对机器B进行写入的客户端产生竞争条件。
  * 另一种创建新的主服务器的方法，就是将从服务器升级(turn)为主服务器，并为升级 后的主服务器创建从服务器。
* 以上列举的两种方法都可以让Redis回到之前的一个主服务器和一个从服务器的状态，而用户接下来要做的就是更新客户端的配置，让它们去读写正确的服务器。除此之外，如果用户需要重启Redis的话，那么可能还需要对服务器的持久化配置进行更新。
* Redis Sentinel可以监视指定的Redis主服务器及其属下的从服务器，并在主服务器下线时自动进行故障转移(failover)。

#### Redis 事务

* 为了保证数据的正确性，我们必须认识到这一点:在多个客户端同时处理相同的数据时，不谨慎的操作很容易会导致数据出错。
* Redis的事务和传统关系数据库的事务并不相同。在关系数据库中，用户首先向数据库服务 器发送BEGIN,然后执行各个相互一致(consistent)的写操作和读操作，最后，用户可以选择 发送COMMIT来确认之前所做的修改，或者发送ROLLBACK来放弃那些修改。
* 在Redis里面也有简单的方法可以处理一连串相互一致的读操作和写操作。Redis的事务以特殊命令MULT工为开始，之后跟着用户传入的多个命令， 最后以EXEC为结束。但是由于这种简单的事务在EXEC命令被调用之前不会执行任何实际 操作，所以用户将没办法根据读取到的数据来做决定。这个问题看上去似乎无足轻重，但 实际上无法以一致的形式读取数据将导致某一类型的问题变得难以解决，除此之外，因为 在多个事务同时处理同一个对象时通常需要用到二阶提交(two-phase commit),所以如果 事务不能以一致的形式读取数据，那么二阶提交将无法实现，从而导致一些原本可以成功 执行的事务沦落至执行失败的地步。比如说:“在市场里面购买一件商品”就是其中一个会 因为无法以一致的形式读取数据而变得难以解决的问题
* 延迟执行事务有助于提升性能 
  * 因为Redis在执行事务的过程中，会延迟执行已入队的命令直到客 户端发送EXEC命令为止。因此，包括本书使用的Python客户端在内的很多Redis客户端都会等到 事务包含的所有命令都出现了之后，才一次性地将MULTI命令、要在事务中执行的一系列命令， 以及EXEC命令全部发送给Redis,然后等待直到接收到所有命令的回复为止。这种“一次性发送 多个命令，然后等待所有回复出现”的做法通常被称为流水线(pipelining),它可以通过减少客户 端与Redis服务器之间的网络通信次数来提升Redis在执行多个命令时的性能。
* 在用户使用WATCH命令对键进行 监视之后，直到用户执行EXEC命令的这段时间里面，如果有其他客户端抢先对任何被监视的键 进行了替换、更新或删除等操作，那么当用户尝试执行EXEC命令的时候，事务将失败并返回一 个错误(之后用户可以选择重试事务或者放弃事务)。通过使用WATCH、MULTI, EXEC、 UNWATCH/DISCARD等命令，程序可以在执行某些重要操作的时候，通过确保自己正在使用的数据没有发生变化来避免数据出错。
* 什么是DISCARD
  * UNWATCH命令可以在WATCH命令执行之后、MULTI命令执行之前对连接进 行重置(reset )；同样地，DISCARD命令也可以在MULTI命令执行之后、EXEC命令执行之前对连接 进行重置。这也就是说，用户在使用WATCH监视一个或多个键，接着使用MULTI开始一个新的事务， 并将多个命令入队到事务队列之后，仍然可以通过发送DISCARD命令来取消WATCH命令并清空所 有已入队命令。本章展示的例子都没有用到DISCARD,主要原因在于我们已经清楚地知道自己是否 想要执行MULTI/EXEC或者UNWATCH,所以没有必要在这些例子里面使用DISCARD.

* 为什么Redis没有实现典型的加锁功能？ 
  * 在访问以写入为目的数据的时候(SQL中的 SELECT FOR UPDATE ),关系数据库会对被访问的数据行进行加锁，直到事务被提交(COMMIT ) 或者被回滚(ROLLBACK)为止。如果有其他客户端试图对被加锁的数据行进行写入，那么该客 户端将被阻塞，直到第一个事务执行完毕为止•加锁在实际使用中非常有效，基本上所有关系数 据库都实现了这种加锁功能，它的缺点在于，持有锁的客户端运行越慢，等待解锁的客户端被阻 塞的时间就越长。
  * 因为加锁有可能会造成长时间的等待，所以Redis为了尽可能地减少客户端的等待时间， 并不会在执行WATCH命令时对数据进行加锁.相反地，Redis只会在数据已经被其他客户端抢 先修改了的情况下，通知执行了 WATCH命令的客户端，这种做法被称为乐观锁(optimistic locking),而关系数据库实际执行的加锁操作则被称为悲观锁(pessimistic locking)o乐观锁在实 际使用中同样非常有效，因为客户端永远不必花时间去等待第一个取得锁的客户端——它们只 需要在自己的事务执行失败时进行重试就可以了。
* 当有多个客户端同时对相同的数据进行操作时，正确地使用事务可以有效地防止数据错误发生。

#### 非事务型流水线

* 在首次介绍MULTI和EXEC的时候讨论过它们的“事务”性质——被MULTI和 EXEC包裹的命令在执行时不会被其他客户端打扰。而使用事务的其中一个好处就是底层的客户 端会通过使用流水线来提高事务执行时的性能。
* 曾经介绍过一些可以接受多个参数的添加命令和更新命令，如MGET、MSET、HMGET、 HMSET、RPUSH和LPUSH、SADD、ZADD等。这些命令简化了那些需要重复执行相同命令的操 作，并且极大地提升了性能。尽管效果可能没有以上提到的命令那么显著，但使用非事务型流水线(non・transactional pipeline )同样可以获得相似的性能提升，并且可以让用户同时执行多个不 同的命令。
* 在需要执行大量命令的情况下，即使命令实际上并不需要放在事务里面执行，但是为了通过 一次发送所有命令来减少通信次数并降低延迟值，用户也可能会将命令包裹在MULTI和EXEC 里面执行。遗憾的是，MULTI和exec并不是免费的——它们也会消耗资源，并且可能会导致其 他重要的命令被延迟执行。

#### 关于性能方面的注意事项

* 习惯了关系数据库的用户在刚开始使用Redis的时候，通常会因为Redis带来的上百倍的性能提升而感到欣喜若狂，却没有认识到Redis的性能实际上还可以做进一步的提高。虽然非事务型流水线可以尽可能地减少应用程序和Redis之间的通信往返次数，但是对于一个 已经存在的应用程序，我们应该如何判断这个程序能否被优化呢？我们又应该如何对它进行优化呢？
* 要对Redis的性能进行优化，用户首先需要弄清楚各种类型的Redis命令到底能跑多块，而 这一点可以通过调用Redis附带的性能测试程序redis-benchmark来得知。

* redis-benchmark的运行结果展示了一些常用Redis命令在1秒内可以执行的次数。如果 用户在不给定任何参数的情况下运行redis-benchmark,那么redis-benchmark将使用 50个客户端来进行性能测试，但是为了在redis-benchmark和我们自己的客户端之间进行性 能对比，让redis-benchmark只使用一个客户端要比使用多个客户端更方便一些。
* 在考察redis-benchmark的输岀结果时，切记不要将输出结果看作是应用程序的实 际性能，这是因为匕edis-benchmark不会处理执行命令所获得的命令回复，所以它节约 了大量用于对命令回复进行语法分析的时间。在一般情况下，对于只使用单个客户端的 redis-benchmark来说，根据被调用命令的复杂度，一个不使用流水线的Python客户端的 性能大概只有redis-benchmark所示性能的50%~60%。
* 另一方面，如果你发现自己客户端的性能只有redis-benchmark所示性能的25%至30%, 或者客户端向你返回了 "Cannot assign requested addressn (无法分配指定的地址)错误，那么你 可能是不小心在每次发送命令时都创建了新的连接。

* 表4-5比较了 Redis在通常情况下的性能表现以及redis-benchmark使用 单客户端进行测试时的结果，并说明了一些可能引起性能问题的原因

  | 性能或者错误                                                 | 可能的原因                                | 解决方法             |
  | ------------------------------------------------------------ | ----------------------------------------- | -------------------- |
  | 单个客户端的性能达到redis-benchmark的50%~60%                 | 这是不使用流水线时的预期性能              | 无                   |
  | 单个客户端的性能达到redis-benchmark的25%〜30%                | 对于每个命令或者每组命令都创 建了新的连接 | 重用已有的Redis 连接 |
  | 客户端返回错误:“ Cannot assign requested address ”(无法分 配指定的地址) | 对于每个命令或者每组命令都创 建了新的连接 | 重用已有的Redis 连接 |

  尽管表4.5列出的性能问题以及问题的解决方法都非常简短，但绝大部分常见的性能问题都 是由表格中列出的原因引起的(另一个引起性能问题的原因是以不正确的方式使用Redis的数据结构)。

* 大部分Redis客户端库都提供了某种级别的内置连接池(connection pool )。以Python的Redis 客户端为例，对于每个Redis服务器，用户只需要创建一个 `redis.Redis()` 对象，该对象就会按需创建连接、重用已有的连接并关闭超时的连接(在使用多个数据库的情况下，即使客户端只连接了一个Redis服务器，它也需要为每一个被使用的数据库创建一个连接)，并且Python客户 端的连接池还可以安全地应用于多线程环境和多进程环境。