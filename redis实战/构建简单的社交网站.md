#### 用户和状态

* 在用户与Twitter进行交互时，用户和状态消息这两类对象是最为重要的。用户对象存储了 用户的基本身份标识信息、用户的关注者人数、用户已发布的状态消息数量等信息。用户对象对 于社交网站来说非常重要，因为它是构建其他可用并且有趣的数据的起点。除了用户对象以外， 状态消息也同样重要，因为它记录了不同的用户都说了些什么，以及不同用户之间进行了什么交 流，这些由用户创建的状态消息是社交网站真正的内容。

##### 用户信息

* 我们使用散列来存储用户信息，这些信息包括用户的用 户名、用户拥有的关注者人数、用户正在关注的人的数量、 用户已经发布的状态消息的数量、用户的注册日期以及其 他一些元信息(meta-information )
* 当一个新用户进行注册的时候，程序需要做的就是根据用户指定的用户名以及当时的时间戳，创建一个正在关注数量、关注者数量、已发布状态消息 数量都被设置为0的对象。
* 创建新用户的函数除了会对存储用户信息的散列进行初始化之外，还会对用户的用户 名进行加锁，这个加锁操作是必须的，它可以防止多个请求(request)在同一时间内使用 相同的用户名来创建新用户。在对用户名进行加锁之后，程序会检查这个用户名是否已经 被其他用户抢先占用了，如果这个用户名尚未被占用的话，那么程序会为这个用户生成一 个独一无二的ID,并将用户名与用户ID进行关联，最后将这个用户信息存储到新创建的 散列里面。
* 敏感的用户信息 
  * 因为程序会频繁地取出存储用户信息的散列用于渲染模板，或者直接用作API请求的回复，所以程序不能将散列后的密码、邮件地址等敏感信息存储在这个用户信息散列里面。从现在开始，我们会假设这些敏感信息都存储在其他键甚至其他数据库里面。

##### 状态消息

* 正如之前所说，程序既会将用户的个人信息存储到用户简介(profile)里面，又会将用户所说的话记录到状态消息里面，并且和存储用户个人 信息时的方法一样，程序也使用散列结构来存储状 态消息。
* 除了消息本身之外，程序还会在散列里面存储消息发布的时间、消息发布者的ID和用户名(这样在处理一个状态消息对象的时候，程序就不必为了获取发布者的用户名而查找发布者的用户对象了), 以及其他一些关于状态消息的附加信息。
* 创建状态消息的函数并没有什么让人感到意外的地方，它首先获取用户的用户名，接着获取 一个新的状态消息ID,最后将所有信息组合起来并将它们存储到散列里面。

#### 主页时间线

* 用户在已登录的情况下访问Twitter时，首先看到的是他们自己的主页时间线，这个时间线是一个列表，它由用户以及用户正在关注的人所发布的状态消息组成。因为主页时间线是用户访问网站时的 主要入口，所以这些数据必须尽可能地易于获取
* 主页时间线将成双成对的状态消息ID和时间戳记录到了有序集合里面，其中时间戳用于对状态消息进行排序，而状态消息ID则用于获取状态消息本身
* 因为主页时间线只存储了状态消息的ID而不是状态消息本身，所以负责获取最新发布的状态消息的函数除了要获取状态消息的ID之外，还需要根据所得的ID获取相应的状态消息数据。 
* 函数会根据状态消息的发布时间，按照从新到旧的顺序从用户指定的时间 线里面获取状态消息，如果用户没有指定要获取的时间线，那么函数默认会获取用户的主页时 间线。
* 除了主页时间线之外，另一个重要的时间线是用户的个人时间线(profile timeline ),这两种 时间线之间的区别在于主页时间线可以包含其他人发布的状态消息，而个人时间线只会包含用户 自己发布的状态消息。用户的个人时间线会在用户的个人页面上进行展示，个人页面是判断一个 用户是否有趣的主要入口。只要在调用get_status_messages ()函数的时候，将timeline 参数的值设置为profile: 就可以获取给定用户发布的状态消息。

#### 关注者列表和正在关注列表

* Twitter这类平台的一个主要作用，就是让用户与其他人分享自己的构思、想法和梦想，在这 些网站上关注一个人意味着你对这个人所说的话感兴趣,并期待着对方也会对你进行关注。
* 用户的主页时间线和个人时间线都是由有序集合存储的，这些有序集合储着状态消息的ID以及状态消息发布时的时间戳。用户的正在关注列表以及关注者列表同样由有序集合存储，其中有序集合的成员为用户ID,而分值则记录了用户开始关注某人或者被某人关 注时的时间戳。
* 为了记录哪些人正在关注给定的用户，程序会将用户ID和时间戳组成一对存储到有序集合里面，其中用户ID记录了是谁在关注给定的用户，而时间戳则记录了他们是在什么时候开始关注给定用户的。与此类似，给定用户正在关注的人也是由组成一对的用户ID和时间戳存储在有序集合里面，其中用户ID记录了被关注的人，而时间戳则记录了给定用户关注他们的时间
* 当用户开始关注或者停止关注另一个用户的时候，程序就需要对这两个用户的正在关注有序集合以及关注者有序集合进行更新，并修改他们在用户信息散列里面记录的关注数量和被关注数 量。如果用户执行的是关注操作，那么程序在对以上提到的有序集合和散列进行更新之后，还需 要从被关注用户的个人时间线里面，复制一些状态消息ID到执行关注操作的用户的主页时间线里面，从而使得用户在关注另一个用户之后，可以立即看见被关注用户所发布的状态消息。
* follow_user()函数的行为和之前描述的一样:它首先将关注者和被关注者双方的用户ID 添加到相应的正在关注有序集合以及关注者有序集合里面，然后获取这两个有序集合的大小，并 从被关注用户的个人时间线上面获取最新的状态消息IDo当函数取得了所需的数据之后，它就 会对用户信息散列里面的正在关注数量以及关注者数量进行更新，并将之前取得的状态消息ID 添加到执行关注操作的用户的主页时间线里面。

* 在关注某个人并阅读他的状态消息一段时间之后，用户可能会想要取消对那个人的关注。实 现取消关注操作的方法和实现关注操作的方法正好相反:程序会从正在关注有序集合以及关注者 有序集合里面移除关注者和被关注者双方的用户ID,并从执行取消关注操作的用户的主页时间 线里面移除被取消关注的人所发布的状态消息，最后对两个用户的正在关注数量以及关注者数量 进行更新。
* unfollow_user()函数会找到执行取消关注操作的用户以及被取消关注的用户，对他们的 正在关注有序集合以及关注者有序集合进行更新，并修改他们的正在关注数量以及关注者数量， 最后从执行取消关注操作的用户的主页时间线里面移除被取消关注的用户所发布的状态消息。至 此，我们已经成功地实现了关注用户和取消关注用户这两个重要的操作。

#### 状态消息的发布与删除

* 在类似Twitter这样的网站上面，用户可以执行的一个最基本的操作就是发布状态消息。人 们通过发布状态消息来与其他人分享自己的想法，并通过阅读其他人发布的状态消息来了解对方 的所见所闻。
* 本节将对状态消息创建之后发生的事情进行介绍，说明一条新的状态消息是如何被添加到每 个关注者的主页时间线里面的。除此之外，本节还会介绍删除已发布的状态消息的方法。
* 本章前面已经介绍了程序是如何创建新的状态消息的，而在此之后，程序要做的就是想 办法把新状态消息的ID添加到每个关注者的主页时间线里面。具体的添加方式会根据消息发 布人拥有的关注者数量的多少而有所不同。如果用户的关注者数量相对比较少(比如说，不 超过1000人)，那么程序可以立即更新每个关注者的主页时间线。但是，如果用户的关注者 数量非常庞大(比如说，100万人，甚至像Twitter ±面的某些人那样，有2500万关注者)， 那么尝试直接执行添加操作将导致发布消息的用户需要长时间地进行等待，超出合理的等待 时间。
* 为了让发布操作可以尽快地返回，程序需要做两件事情。首先，在发布状态消息的时候，程 序会将状态消息的ID添加到前1000个关注者的主页时间线里面。根据Twitter的一项统计表明, 关注者数量在1000人以上的用户只有10万〜25万，而这10万〜25万用户只占了活跃用户数量 的0.1%,这意味着99.9%的消息发布人在这一阶段就可以完成自己的发布操作，而剩下的0.1% 则需要接着执行下一个步骤。其次，对于那些关注者数量超过1000人的用户来说，程序会使用类似于6.4节中介绍的系 统来开始一项延迟任务。
* 除了思考如何发布状态消息之外，我们还要考虑如何去删除一条已经发布的状态消息。
* 删除一条状态消息的方法实际上非常简单，因为get_status_messages ()函数在返回那些被取出的状态消息之前，会先使用Python的filter ()函数过滤掉所有已经被删除了的状态消息， 所以在删除一条状态消息的时候，程序只需要删除存储了那条状态消息的散列，并对消息发送者的 已发送状态消息数量进行更新就可以了。代码清单8-8展示了用于删除已发布的状态消息的函数。
* 在删除状态消息并对用户已发布状态消息数量进行更新的同时，delete_status()函数还 会从用户的主页时间线和个人时间线里面移除被删除的状态消息
* 当一条状态消息被删除之后，这条消息的ID就会残留在所有关注者的主页时间线里面，我们应当清理被删除状态消息的ID
* 从用户的角度来看，能够发布和删除状态消息多多少少就算是完成了仿Twitter社交网站的基本 功能了。如果读者想要进一步提高这个网站的用户体验的话，那么可以考虑给网站增加以下特性。
  * 私人用户，关注这些用户需要经过主人的批准。
  * 收藏(注意状态消息的私密性)
  * 用户之间可以进行私聊。
  * 对消息进行回复将产生一个会话流(conversation flow )
  * 转发消息。
  * 使用@指名一个用户，或者使用#标记一个话题。
  * 记录用户使用@指名了谁。
  * 针对广告行为和滥用行为的投诉与管理机制。
* 以上提到的特性可以使我们的仿Twitter网站的功能变得更加丰富，不过这些特性并非在所 有情况下都是必需的，读者可以根据自己的需要选择添加哪些特性。除了 Twitter提供的特性之 外，读者也可以考虑添加一些来自其他社交网站的附加功能。
  * 对状态消息进行“赞”或者+1
  * 根据“重要性”对状态消息进行排序。
  * 在预先设置的一群用户之间进行私聊。
  * 对用户进行分组，只有组员能够关注组时间线(group timeline )并在里面发布状态消息。 小组可以是公开的、私密的甚至是公告形式的。

#### 流  API

* 在开发社交网站的过程中，我们可能会想要知道更多网站上正在发生的事情——比如网站每 个小时会发布多少条新的状态消息，网站上最热门的主题是什么，网站上最经常被@指名的人是 谁，诸如此类。要做到这一点，我们既可以专门执行一些调用(call)来收集这些信息，也可以在所有执行操作的函数内部记录这些信息，还有一种方——就是构建一些函数来广播(broadcast)简单的事件(event),然后由负责进行数据分析的事件监听器 (event listener )来接收并处理这些事件
* 流API跟我们前面为了仿制Twitter而构建的其他部分完全不同，前面几节实现的Twitter典型操作都需要尽快地执行并完成，而流API请求则需要在一段比较长的时间内持续地返回数据。
* 大多数新型社交网站都允许用户通过API获取信息。Twitter最近几年来的一个优势就在于, 通过向第三方合作伙伴提供实时事件(real・time event),合作伙伴可以对数据进行各式各样新颖有趣的分析，而这些分析可能是Twitter自己没有时间或者没有兴趣开发的。
* 作为构建流API的第一步，让我们先来思考一下，自己到底想要处理和生产什么样的数据。

##### 流API提供的数据

* 当用户使用我们的社交网站时，他们的一举一动都可以通过网站定义的API函数看到。在前面几节，我们花了大量时间来实现关注用户、取消关注用户、发布消息和删除消息这4个功能， 随着我们不断地为社交网站开发新功能，用户的行为还会产生其他不同的事件。**而流API的作用就是随着时间的推移，产生一个由事件组成的序列，以此来让整个网络上的客户端和其他服务及 时地了解到网站目前正在发生的事情**。
* 在构建流API的过程中需要进行各式各样的决策，这些决策主要和以下3个问题有关。
  * 流API需要对外公开哪些事件？
  * 是否需要进行访问限制？如果需要的话，采取何种方式实现？
  * 流API应该提供哪些过滤选项？
* 只有在社交网站涉及用户隐私或者系统资源的时候，我们才需要考虑访问限制的问题。
* 既然我们的社交网站已经实现了发布消息、删除消息、关注用户和取消关注用户这几个动作, 那么我们至少应该为这些动作提供一些事件。为了简单起见，目前我们只会创建发布消息事件和 删除消息事件，但是以本节创建和分发的结构为基础，为关注用户、取消关注用户、甚至是之后 添加的其他动作创建相应的事件应该都不是一件难事。
* 我们的社交网站提供的过滤选项(filtering option )在特性和功能方面与Twitter为公开流 (public stream )'提供的API非常相似:用户既可以通过关注过滤器(基于用户进行过滤)、监测过滤器(基于关键字进行过滤)以及位置过滤器来获取过滤后的消息, 又可以通过类似Twitter 的消防水管(firehose )和样本(sample)这样的流来获取一些随机的消息。
* 在了解了使用流API可以取得哪些数据之后，接下来就让我们来看看流API是怎样提供这些数据的。

##### 提供数据

* 每当我们展示向Redis发送命令请求的函数时，都会假设某个已经存在的 Web 服务器会在合适的时候调用这个函数。但是**对于流API来说，向客户端提供流式数据所需的步骤比起简单地将函数插入(plug )到已有的Web服务栈(stack )里面要复杂得多。这是因为绝 大多数Web服务器在执行操作的时候，都假设程序会一次性地将全部回复返回给请求，然而这 种假设并不适用于流API**
* 每当新诞生的状态消息与过滤器相匹配的时候，流API就会将这条消息返回给客户端。尽管 WebScokets和SPDY这样的新技术可以以增量的方式不断地生成数据，甚至进行服务器端的消息推送，但是这些技术的相关协议并未完全制定好，而且很多编程语言的客户端也未能完全地支持这些新技术。幸运的是，只要使用分块(chunked)传输编码，我们就可以使用HTTP服务器生成并发送增量式数据。
* 本节将构建一个简单的Web服务器，它可以通过分块HTTP回复向客户端返回流式数据。 而接下来的一节则会在这个简单Web服务器的基础上，实现针对流式消息数据(streamed message data )的过滤功能

* HTTP流服务器
  * Python提供了一系列套接字服务器函数库，通过混合这些库可以实现各种不同的功能。首先, 我们会创建一个以多线程方式处理已到达请求的服务器，这个服务器每次接收到一个请求，都会 创建一个新的线程来执行请求处理器(request handler),而请求处理器则会对GET和POST形式 的HTTP请求进行一些非常简单的路由操作。
* 