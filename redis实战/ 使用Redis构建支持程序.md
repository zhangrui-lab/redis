#### 使用 Redis 来记录日志

* 在构建应用程序和服务的过程中，对正在运行的系统的相关信息的挖掘能力将变得越来越重 要:无论是通过挖掘信息来诊断系统问题，还是发现系统中潜在的问题，甚至是挖掘与用户有 关的信息——这些都需要用到日志。
* 在Linux和Unix的世界中，有两种常见的记录日志的方法。第一种是将日志记录到文件 里面，然后随着时间流逝不断地将一个又一个日志行添加到文件里面，并在一段时间之后创 建新的日志文件。包括Redis在内的很多软件都使用这种方法来记录日志。但这种记录日志 的方式有时候可能会遇上麻烦:因为每个不同的服务都会创建不同的日志，而这些服务轮换 (rolling )日志的机制也各不相同，并且也缺少一种能够方便地聚合所有日志并对其进行处理的常用方法。
* syslog服务是第二种常用的日志记录方法，这个服务运行在几乎所有Linux服务器和Unix 服务器的514号TCP端口和UDP端口上面。syslog接受其他程序发来的日志消息，并将这些消 息路由(route)至存储在硬盘上的各个日志文件里面，除此之外，syslog还负责旧日志的轮换和 删除工作。通过配置，syslog甚至可以将日志消息转发给其他服务来做进一步的处理。因为对指 定日志的轮换和删除工作都可以交给syslog来完成，所以使用syslog服务比直接将日志写入文件 要方便得多。
* 替换syslog
  * 无论读者使用上面列举的两种日志记录方法中的哪一种，都最好考虑把系统目前的syslog守护进程(通常是Rsyslogd )替换成syslog-ngo因为我经过使用并配置Rsyslogd 和syslog-ng之后，发现syslog-ng用于管理和组织日志消息的配置语言使用起来更简单 一些。另外，尽管因为时间和篇幅所限，我没办法在书中构建一个处理syslog消息并将消息存 储到Redis里面的服务，但对于那些需要在处理请求时立即执行的操作，以及那些可以在请求 处理完毕之后再执行的操作(如记录日志和更新计数器)来说，这种服务非常适合用作介于 这两种操作之间的间接层。
* syslog的转发功能可以将不同的日志分别存储到同一台服务器的多个文件里面，这对于长时 间地记录日志非常有帮助(记得备份)。

#### 最新日志

* 在构建一个系统的时候，判断哪些信息需要被记录是一件困难的事情:需要记录用户 的登入和登出行为吗？需要记录用户修改账号信息的时间吗？还是只记录错误和异常就可 以了？虽然我没办法替你回答这些问题，但我可以向你提供一种将最新出现的日志消息以 列表的形式存储到Redis里面的方法，这个列表可以帮助你随时了解最新出现的日志都是什 么样子的。

##### 常见日志

* 程序会将 消息作为成员存储到有序集合里面，并将消息出现的频率设置为成员的分值。为了确保我们看见 的常见消息都是最新的，程序会以每小时一次的频率对消息进行轮换，并在轮换日志的时候保留 上一个小时记录的常见消息，从而防止没有任何消息存在的情况出现。

#### 计数器和统计数据

* 通过记录各个页面的被访问次数，我们可以根据基本的访问计数信息来决 定如何缓存页面。
* 知道我们的网站在最近5分钟内获得了 10 000次点击，或者数据库在最近5秒内处理了 200 次写入和600次读取，是非常有用的。通过在一段时间内持续地记录这些信息，我们可以注意到 流量的骤增或渐增情况，预测何时需要对服务器进行升级，从而防止系统因为负荷超载而下线。

##### 将计数器存储到Redis里面

* 在监控应用程序的同时，持续地收集信息是一件非常重要的事情。那些影响网站响应速度以及网 站所能服务的页面数量的代码改动、新的广告营销活动或者是刚刚接触系统的新用户，都有可能会彻 底地改变网站载入页面的数量，并因此而影响网站的各项性能指标。但如果我们平时不记录任何指标 数据的话，我们就不可能知道指标发生了变化，也就不可能知道网站的性能是在提高还是在下降。
* 实现计数器首先要考虑的就是如何存储计数器信息

###### 对计数器进行更新

* 为了对计数器进行更新，我们需要存储实际的计数器信息。对于每个计数器以及每种精度， 如网站点击量计数器和5秒，我们将使用一个散列来存储网站在每个5秒时间片(time slice )之 内获得的点击量，其中，散列的每个键都是某个时间片的开始时间，而键对应的值则存储了网站 在该时间片之内获得的点击量。
* 为了能够清理计数器包含的旧数据，我们需要在使用计数器的同时，对被使用的计数器进行记录。为了做到这一点，我们需要一个有序序列(ordered sequence ),这个序列不能包含任何重复元素，并且能够让我们一个接一个地遍历序列中包含的所有元素。虽然同时使用列表和集合可以实现这种序列，但同时使用两种数据结构需要编写更多代码，并且会增加客户端和Redis之间的通信往返次数。实际上，实现有序序列更好的办法是使用有序集合，有序集合的各个成员分别 由计数器的精度以及计数器的名字组成，而所有成员的分值都为0。因为所有成员的分值都被设置成了 0,所以Redis在尝试按分值对有序集合进行排序的时候，就会发现这一点，并改为使用 成员名进行排序，这使得一组给定的成员总是具有固定的排列顺序，从而可以方便地对这些 成员进行顺序性的扫描。

###### 清理旧计数器

* 如果我们只是一味地对计数器进行更新而不执行任何清理操作的话，那么程序最终将 会因为存储了过多的数据而导致内存不足。好在我们事先已经将所有已知的计数器都记录到了一个 有序集合里面，所以对计数器进行清理只需要遍历有序集合并删除其中的旧计数器就可以了。
* 为什么不使用EXPIRE? 
  * expire命令的其中一个限制就是它只能应用于整个键，而不能只对键 的某一部分数据进行过期处理。并且因为我们将同一个计数器在不同精度下的所有计数数据都存放 到了同一个键里面，所以我们必须定期地对计数器进行清理。
* 在处理(process )和清理(clean叩)旧计数器的时候，有几件事情是需要我们格外留心的， 其中包括以下几件。
  * 任何时候都可能会有新的计数器被添加进来。
  * 同一时间可能会有多个不同的清理操作在执行。
  * 对于一个每天只更新一次的计数器来说，以每分钟一次的频率尝试清理这个计数器只会浪费计算资源。
  * 如果一个计数器不包含任何数据，那么程序就不应该尝试对它进行清理。
* 为了尽可能地降低清理操作的执行负载， 守护进程会以每分钟一次的频率清理那些每分钟更新一次或者每分钟更新多次的计数器，而对于那些更新频率低于每分钟一次的计数器，守护进程则会根据计数器自身的更新频率来决定对它们进行清理的频率。比如说，对于每秒更新一次或者每5秒更新一次的计数器，守护进程将以每分钟一次的频率清理这些计数器；而对于每5分钟更新一次的计数器，守护进程将以每5分钟一次的频率清理这些计数器。
* 清理程序通过对记录已知计数器的有序集合执行ZRANGE命令来一个接一个的遍历所有已知的计数器。在对计数器执行清理操作的时候，程序会取出计数器记录的所有计数样本的开始时间， 并移除那些开始时间位于指定截止时间之前的样本，清理之后的计数器最多只会保留最新的120个 样本。如果一个计数器在执行清理操作之后不再包含任何样本，那么程序将从记录已知计数器的有序集合里面移除这个计数器的引用信息。
* 正如之前所说，clean_counters ()函数会一接一个地遍历有序集合里面记录的计数器， 查找需要进行清理的计数器。程序在每次遍历时都会对计数器进行检查，确保只清理应该清理的 计数器。当程序尝试清理一个计数器的时候，它会取出计数器记录的所有数据样本，并判断哪些样本是需要被删除的。如果程序在对一个计数器执行清理操作之后，认为这个计数器已经不再包 含任何数据，那么程序会检查这个计数器是否已经被清空，并在确认了它已经被清空之后，将它 从记录已知计数器的有序集合中移除。最后，在遍历完所有计数器之后，程序会计算此次遍历耗 费的时长，如果为了执行清理操作而预留的一分钟时间没有完全耗尽，那么程序将休眠直到这一 分钟过去为止，然后继续进行下次遍历。
* 在和一个真实的网站打交道的时候，知道页面每天的点击量可以帮助我们判断是否需要对页面进行缓存。但是，如果被频繁访问的页面只需要花费2毫秒来进行渲染，而其他流量只有十分之一的页面却需要花费2秒来进行渲染，那么在缓存被频繁访问的页面之前，我们可以先将注意 力放到优化渲染速度较慢的页面上面。

##### 使用Redis存储统计数据

* 对于一种给定的上下文(context)和类型，程序将使用一个有序集合来记录这个上下文以及这个类型的最小值(min)、最大值(max )、 样本数量(count)值的和(sum )、值的平方之和(sumsq )等信息，并通过这些 信息来计算平均值以及标准差。程序将 值存储在有序集合里面并非是为了按照 分值对成员进行排序，而是为了对存储 着统计信息的有序集合和其他有序集合 进行并集计算，并通过MIN和MAX这两个聚合函数来筛选相交的元素。
* 既然我们已经知道了程序要存储的是什么类型的数据，那么接下来要考虑的就是如何将这些数据 写到数据结构里面了。统计程序在写入数据之前会进行检查，确保被记录的是当前这个小时的统计数据，并将不属于当前这个小时的旧数据进行归档。在此之后，程序会构建两个临时有序集合，其中一个用于保存最小值，而另一个则用于保存最大值。然后使用ZUNIONST0RE命令以及它的两个聚合函数MIN和MAX, 分别计算两个临时有序集合与记录当前统计数据的有序集合之间的并集结果。通过使用ZUNIONSTORE 命令，程序可以快速地更新统计数据，而无需使用WATCH去监视可能会频繁进行更新的存储统计数据 的键，因为这个键可能会频繁地进行更新。程序在并集计算完毕之后就会删除那些临时有序集合，并使用ZINCRBY命令对统计数据有序集合里面的count、sum. sumsq这3个成员进行更新。

##### 简化统计数据的记录与发现

* 在将统计数据存储到Redis里面之后，接下来我们该做些什么呢？说得更详细一点，在知道了访问每个页面所需的时间之后，我们要怎样才能找到那些生成速度较慢的网页？或者说，当某个页面的生成速度变得比以往要慢的时候，我们如何才能知悉这一情况？简单来说，为了发现以上提到的这些情况，我们需要存储更多信息。
* 要记录页面的访问时长，程序就必须在页面被访问时进行计时。为了做到这一点，我们可以 在各个不同的页面设置计时器，并添加代码来记录计时的结果，但更好的办法是直接实现一个能够进行计时并将计时结果存储起来的东西，让它将平均访问速度最慢的页面都记录到一个有序集合里面，并向我们报告哪些页面的载入时间变得比以前更长了。

#### 查找 IP 所属城市以及国家

* 通过将统计数据和日志存储到Redis里面，我们可以收集访客在系统中的行为信息。但是直 到目前为止，我们都忽略了访客行为中非常重要的一个部分，那就是——这些访客是从哪里来 的？为了回答这个问题，在这一节中，我们将构建一系列用于分析和载入IP所属地数据库的函 数，并编写一个可以根据访客的IP地址来查找访客所在城市、行政区(州)以及国家的函数。

* 我们之所以使用Redis而不是传统的关系数据库来实现IP所属地查找功能，是因为Redis实现的IP所属地查找程序在运行速度上更具优势。另一方面，因为对用户进行定位所需的信息量非常庞大，在应用程序启动时载入这些信息将影响应用程序的启动速度，所以我们也没有使用本 地查找表(local lookup table)来实现IP所属地查找功能。实现IP所属地查找功能首先要做的就是将一些数据表载入Redis里面

* 实现IP所属地查找程序会用到两个查找表，第一个查找表需要根据输入的 IP地址来査找IP 所属城市的ID,而第二个查找表则需要根据输入的城市 ID 来查找 ID 对应城市的实际信息(这个城市信息中还会包括城市所在地区和国家的相关信息)。

* 根据IP地址来查找城市ID的查找表由有序集合实现，这个有序集合的成员为具体的城市ID, 而分值则是一个根据IP地址计算出来的整数值。为了创建IP地址与城市ID之间的映射，程序 需要将点分十进制格式的IP地址转换为一个整数分值

  ```python
  def ip_to_score(ip_address):
    score = 0
    for v in ip_address.split('.'):
      score = score * 256 + int(v, 10)
    return score
  // 整个转换过程:IP地址中的每8个二进制位会被看作是无符号整数中的1字节，其中 IP 地址最开头的8个二进制位为最高位。
  ```

* 在将IP地址转换为整数分值之后，程序就可以创建IP地址与城市ID之间的映射了。因为 多个IP地址范围可能会被映射至同一个城市ID,所以程序会在普通的城市ID后面，加上一个 _ 字符以及有序集合目前已有城市ID的数量，以此来构建一个独一无二的唯一城市ID。

##### 查找IP所属城市

* 为了实现IP地址查找功能，我们在上一个小节已经将代表城市ID所属IP地址段起始端 (beginning )的整数分值添加到了有序集合里面。要根据给定IP地址来查找所属城市，程序首先会使用ip_to_score ()函数将给定的IP地址转换为分值，然后在所有分值小于或等于给定 IP 地址的IP地址里面，找岀分值最大的那个IP地址所对应的城市ID。这个查找城市ID的操作可以通过调用ZREVRANGEBYSCORE命令并将选项START和NUM的参数分别设为0和1来完成。 在找到城市ID之后，程序就可以在存储着城市ID与城市信息映射的散列里面获取ID对应城市 的信息了。
* 将数据转换为整数并搭配有序集合进行操作的做法非常有用，它可以极大地简化对特定元素或特定范围的査找工作。

#### 服务的发现与配置

* 随着我们越来越多地使用Redis以及其他服务，如何存储各项服务的配置信息将变成一个棘手的问题:对于一个Redis服务器、一个数据库服务器以及一个Web服务器来说，存储它们的配置信息并不困难；但如果我们使用了一个拥有好几个从服务器的Redis主服务器，或者为不同的应用程序设置了不同的Redis服务器，甚至为数据库也设置了主服务器和从服务器的话，那么存储这些服务器的配置信息将变成一件让人头疼的事情。
* 用于连接其他服务以及服务器的配置信息一般都是以配置文件的形式存储在硬盘里面，每当机器下线、网络连接断开或者某些需要连接其他服务器的情况出现时，程序通常需要一次性地对不同服务器中的多个配置文件进行更新。而这一节要介绍的就是如何将大部分配置信息从文件转移到Redis里面，使得应用程序可以自己完成绝大部分配置工作。

##### 使用Redis存储配置信息

* 为了展示配置管理方面的难题是多么的常见，来看一个非常简单的配置例子——所设现在我 们要用一个标志(flag)来表示Web服务器是否正在进行维护:如果服务器正在进行维护，那么 它就不应该发送数据库请求，而是应该向访客们返回一条简短的“抱歉，我们正在进行维护，请稍候再试”的信息；与此相反，如果服务器并没有在进行维护，那么它就应该按照既定的程序来运行。
* 在通常情况下，即使只更新配置中的一个标志，也会导致更新后的配置文件被强制推送至所有Web服务器，收到更新的服务器可能需要重新载入配置，甚至可能还要重启应用程序服务器。
* 与其尝试为不断增多的服务写入和维护配置文件，不如让我们直接将配置写入Redis里面。只要将配置信息存储在Redis里面，并编写应用程序来获取这些信息，我们就不用再编写工具来向服务器推送配置信息了，服务器和服务也不用再通过重新载入配置文件的方式来更新配置信息了。
* 为了实现这个简单的功能，让我们假设自己已经构建了一个中间层或者插件，它和我们为了缓存页面而构建的中间层类似,这个中间层的作用在于:当is_under_maintenance()  函数返回True时，它将向用户显示维护页面；与此相反，如果is_under_maintenance () 函数返回False, 它将如常地处理用户的访问请求。其中，is_under_maintenance() 函数 通过检查一个名为is-under-maintenance的键来判断服务器是否正在进行维护:如果 is-under-maintenance 非空，那么函数返回True；否则返回False。另外，因为访客在看见维护页面的时候通常都会不耐烦地频繁刷新页面，所以为了尽量降低Redis在处理高访问量 Web 服务器时的负载，is_under_maintenance() 函数最多只会每秒更新一次服务器维护信息。

##### 为每个应用程序组件分别配置一个Redis服务器

* 在我们越来越多地使用Redis的过程中，无数的开发者已经发现，最终在某个时间点上，只使用一台Redis服务器将不能满足我们的需求。因为我们可能需要记录更多信息，可能需要更多用于缓存的空间，还可能会使用之后会介绍到的、使用Redis构建的高级服务。但不管何种原因，我们都需要用到更多Redis服务器。

* 为了平滑地从单台服务器过渡到多台服务器，用户最好还是为应用程序中的每个独立部分都分别运行一个Redis服务器，比如说，一个专门负责记录日志、一个专门负责记录统计数据、一 个专门负责进行缓存、一个专门负责存储cookies等。别忘了，一台机器上是可以运行多个Redis 服务器的，只要这些服务器使用的端口号各不同就可以了。除此之外，在一个Redis服务器里面使用多个“数据库”，也可以减少系统管理的工作量

* 以上提到的两种方法，都是通过将不同数据划分至不同键空间(key space )的方式，来或多或少地简化迁移至更大或者更多服务器时所需的工作。但遗憾的是，随着Redis服务器的数量或者Redis数据库的数量不断增多，为所有 Redis 服务器管理和分发配置信息的工作将变得越来越烦琐和无趣。

* 在之前，我们使用了 Redis 来存储表示服务器是否正在进行维护的标志，并通过这个标志来决定是否需要向访客显示维护页面。而这一次，我们同样可以使用Redis来存储与其他 Redis 服务器有关的信息。说得更详细一点，我们可以把一个已知的Redis服务器用作配置信息字典，

* 然后通过这个字典存储的配置信息来连接为不同应用或服务组件提供数据的其他Redis服务器。 此外，这个字典还会在配置出现变更时，帮助客户端连接至正确的服务器。字典的具体实现比这个例子所要求的更为通用一些，因为我敢肯定，当你开始使用这个字典来获取配置信息的时候， 你很快就会把它应用到其他服务器以及其他服务上面，而不仅仅用于获取 Redis 服务器的配置信息。

* 我们将构建一个函数，该函数可以从一个键里面取出一个 JSON 编码的配置值，其中，存储配置值的键由服务的类型以及使用该服务的应用程序命名。举个例子，如果我们想要获取连接存 储统计数据的Redis服务器所需的信息，那么就需要获取 config:redis:statistics 键的值。

  ```
  def set_config(conn, type, component, config):
    conn.set('config:%s:%s'(type, component), json.dumps(config))
  ```

  通过这个set_config()函数，我们可以随心所欲地设置任何 JSON 编码的配置信息。因为get_config()函数和前面介绍过的is_under_maintenance ()函数具有相似的结构，所以我们只要在语义上稍作修改，就可以使用get_config()函数来代替is_under_maintenance() 函数。这个函数可以 按照用户的需要，对配置信息进行0秒、1秒或者10秒的局部缓存。

  ```
  CONFIGS = {}
  CHECKED = {}
  def get_config(conn, type, component, wait=l):
    key = 'config:%s:%s'%(type, component)
    if CHECKED.get(key) < time.time() - wait:
    	CHECKED[key] = time.time
      config = json.loads(conn.get(key)
      config = diet((str(k), config[k]) for k in config) 
  		old_config = CONFIGS.get(key)	
      if config != old_config:
      	CONFIGS[key] = config
    return CONFIGS.get(key)
  ```

  在拥有了设置配置信息和获取配置信息的两个函数之后，我们还可以在此之上更进一步。我们在前面一直考虑的都是怎样存储和获取配置信息以便连接各个不同的 Redis 服务器，但直到目前为止，我们编写的绝大多数函数的第一个参数都是一个连接参数。因此，为了不再需要手动获取我们正在使用的各项服务的连接，下面让我们来构建一个能够帮助我们自动连接这些服务的方法。

##### 自动Redis连接管理

* 手动创建和传递Redis连接并不是一件容易的事情，这不仅仅是因为我们需要重复查阅配置信息，还有一个原因就是，即使使用了上一节介绍的配置管理函数，我们还是需要获取配置、连接Redis, 并在使用完连接之后关闭连接。为了简化连接的管理操作，我们将编写一个装饰器 (decorator), 让它负责连接除配置服务器之外的所有其他Redis服务器。

* 装饰器Python提供了一种语法，用于将函数X传入至另一个函数Y的内部，其中函数Y就被称为装饰器。装饰器给用户提供了一个修改函数X行为的机会。有些装饰器可以用于校验参数，而有些装饰器则可以用于注册回调函数，甚至还有一些装饰器可以用于管理连接一就像我们接下来要做的那样。

* 代码清单展示了我们定义的装饰器，它接受一个指定的配置作为参数并生成一个包装器(wrapper),这个包装器可以包裹起一个函数，使得之后对被包裹函数的调用可以自动连接至正确的Redis服务器，并且连接Redis服务器所使用的那个连接会和用户之后提供的其他参数一同传递至被包裹的函数。

  ```python
  REDIS_C0NNECTI0NS = {}
    def redis_connection(component, wait=l): 
      key = 'config:redis:' + component 
      def wrapper(function):
        @functools.wraps(function)
        def call(*args, **kwargs):
          old_config = CONFIGS.get(key, object()}
          _config = get_config(config_connection, 'redis', component, wait) 
          config = {}
          for kz v in _config.iteritems(): 
            config[k.encode('utf-8')] = v
          if config != old_config:
            REDIS_CONNECTIONS[key] = redis.Redis(**config)
          return function(REDIS_CONNECTIONS.get(key), *args, **kwargs) 
       return call
     return wrapper
  ```

  redis_connection() 装饰器接受一个应用组件的名字作为参数并返回一个包装器。这个包装器接受一个我们想要将连接传递给它的函数为参数，然后对函数进行包裹并返回被包裹函数的调用器(caller )。这个调用器负责处理所有获取配置信息的工作，除此之外， 它还负责连接Redis服务器并调用被包裹的函数。

* 这里的装饰指的是“将一个函数传递给装饰器，让装饰器在返回被传入的函数之前，对被传入的函数执行一些操作“